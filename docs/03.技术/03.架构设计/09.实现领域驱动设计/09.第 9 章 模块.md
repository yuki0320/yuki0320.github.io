---
title: 第 9 章 模块
date: 2021-01-07 16:25:13
permalink: /pages/f8d411/
categories:
  - 技术
  - 技术文档
  - 实现领域驱动设计
tags:
  - 
---
# 第 9 章 模块

The secret of all victory lies in the organization of the non-obvious.

> 胜利的秘诀在于组织好民众。

——Marcus Aurelius

If you are using Java or C#, you are already familiar with Modules, though you know them by another name. Java calls them packages. C# calls them namespaces. Actually in Ruby you can use the module language construct to effect namespaces for classes. In Ruby’s case the DDD pattern name matches the name of the language construct. For the sake of our DDD context I will continue to call them Modules in most cases. It will be easy for you to map that name to the programming language term you regularly use. I won’t spend much time trying to explain technically what Modules do, because you probably figured that out long ago.

> 如果你正使用 Java 或者 C#，那么你应该对模块（Module）已经非常熟悉了。在 Java 中，模块称为包；在 C#中，模块称为命名空间。在 Ruby 中，我们可以通过 module 关键字来达到创建命名空间的效果。将模块映射到特定编程语言中的术语是简单的。这里，我不会花太多时间从技术上去解释模块的功能，对此你可能早已经知道了。

Road Map to This Chapter 本章学习路线图

- Learn the difference between traditional Modules and the newer deployment modularity approach.
- Consider the importance of naming Modules per the Ubiquitous Language (1).
- See how designing Modules mechanically actually stifles modeling creativity.
- Learn the design choices and trade-offs made by the SaaSOvation teams.
- Find out the role Modules play outside the domain model, and when to favor new Modules over new Bounded Contexts.

---

> - 学习传统的模块和新的部署模块化之间的区别。
> - 学习通过通用语言（1）来命名模块的重要性。
> - 学习机械式模块是如何给建模带来阻碍的。
> - 学习 SaaSOvation 团队是如何设计模块的。
> - 学习模块在领域模型之外所扮演的角色，以及何时应该使用新的模块而不是新的限界上下文。

## 9.1 DESIGNING WITH MODULES 通过模块完成设计

In a DDD context, Modules in your model serve as named containers for domain object classes that are highly cohesive with one another. The goal should be low coupling between the classes that are in different Modules. Since Modules as used in DDD are not bland or generic storage compartments, it is also important to properly name the Modules. Their names are an important facet of the Ubiquitous Language.

> 在 DDD 中，模型中的模块表示了一个命名的容器，用于存放领域中内聚在一起的类。将类放在不同模块中的目的在于达到松耦合性。由于 DDD 中的模块并不是一个通用的存储区域，因此对其进行适当的命名是重要的。事实上，模块名是通用语言的重要组成部分。

Choose Modules that tell the story of the system and contain a cohesive set of concepts. This often yields low coupling among Modules, but if it doesn’t, look for a way to change the model to disentangle the concepts. . . . Give Modules names that become part of the Ubiquitous Language. Modules and their names should reflect insight into the domain. [Evans, pp. 110, 111]

> 模块应该包含一组具有高内聚性的概念集合，这样做的好处是可以在不同的模块之间实现松耦合。否则，我们应该修改模型以重新划分这些概念。……由于模块名是通用语言的一部分，模块名应该反映出它们在领域中的概念。[Evans，pp.110，111]

There are a few simple rules to keep in mind when designing Modules, as noted in Table 9.1.

> 在设计模块时，有几条简单的原则，如表 9.1 所示。

Table 9.1. Simple Rules for Module Design

Image

Image

View Modules as first-class citizens of the model, and strive to create ones with as much meaning and naming consideration as is given to Entities (5), Value Objects (6), Services, and Events (8). This means being aggressive enough to rename existing Modules with the same boldness as when creating new ones. Always assertively place fresh and freshened domain concepts into the Modules that contemporary insight calls for.

> 我们应该将模块看作模型中的一等公民，在设计和命名上应该给予和实体（5）、值对象（6）、领域服务和领域事件（8）同等的重视程度。这意味着在有必要为模块重命名时，我们就应该为其重命名，并且按需地、及时地将领域概念添加到模块中。

None of us would feel good about opening a drawer in our home kitchen and finding a disorganized assortment of forks, knives, spoons, wrenches, screwdrivers, sockets, and hammers. We would probably at least refuse to eat with the silverware, even if we could gather a full place setting. We might avoid digging through the disorganized drawer to look for a particular screwdriver out of fear of being sliced by an undetected butcher’s knife.

> 我想，没有人愿意看到自己厨房的抽屉里杂乱无章地放着各种刀叉、勺子、螺丝刀、插线板和榔头等。此时，估计你也不再想用里面的刀叉来用食了。另外，你也不想翻来覆去地在抽屉里去找螺丝刀了，因为你怕一不小心被刀子给割伤。

Contrast this with a kitchen drawer that has silverware neatly organized into sets of forks, knives, and spoons, and a toolbox in your garage where each type of tool has its own well-arranged drawer. We would have no problem finding what we need to use for a specific purpose, or hesitate to put it to its intended use. Everything is well organized, uncluttered. With all this modular organization in place, no one would expect to find cups and saucers in the drawer with silverware, even though both belong in the kitchen. The neat stacks of tableware would likely lead us to believe that cups and saucers have a proper place of their own. A few quick glances into nearby obvious-looking cabinets, and there they would be. We would likewise expect to find sharp cutlery in a location that promised to protect their edges and protect those intending to use them.

> 相比之下，如果我们只在抽屉里整齐地存放刀叉、勺子等进餐用具，而将螺丝刀、榔头等工具分类存放在车库的不同抽屉里，你是不是会乐意得多？所有的东西都被很好地组织起来。有了这些组织良好的模块，我们不再需要从存放餐具的抽屉里去找杯具和茶碟之类的东西。我们完全可以预知，杯具和茶碟应该放在另一个属于它们自己的抽屉里。同时，那些锋利的刀具也另有专门的存放地点。

On the other hand, we would probably not organize our kitchen’s contents using a mechanical approach, such as placing all sturdy things in one drawer and all things that might break in a high cabinet. We wouldn’t want to have to remember that our flower vases are kept with our fine teacups just because both are somewhat fragile. Neither would we want to remember that we keep our stainless steel meat tenderizer with the fine cutlery just because both kinds of devices are in little danger of damage by the other sturdy ones.

> 另一方面，我们也不会机械式地对厨房物品进行分类，比如将一些坚硬的东西放在一个抽屉里，而将所有易碎的东西放在另一个抽屉里。我们才不会因为花瓶和茶杯都是易碎的而将它们放在一起呢。

If we were modeling a kitchen, it would be perfectly natural to see a Module named placesettings, and in it we would see objects such as Fork, Spoon, and Knife. Possibly we might even decide to place Serviette there as well, proving that it’s not only being made of metal that qualifies an object to be a part of the placesettings Module. On the other hand, it would be less helpful to modeling place settings if we had separate Modules named pronged, scooping, and blunt.

> 如果我们要对一个厨房进行建模，很自然地，我们希望创建一个名为 placesettings 的模块，其中包含 Fork、Spoon 和 Knife 等对象。另外，我们还可以将 Serviette 放入其中，表明该模块不只是存放金属器具的地方。另一方面，如果我们分别创建名为 pronged、scooping 和 blunt 的模块，那么这样的用处并不大。

Note that more recent advances in the modularization of software have led to a different level of software modularity. This approach has to do with the packaging of loosely coupled yet logically cohesive segments of software into a deployment unit by version. In a Java ecosystem we still think in terms of JAR files, but with those now assembled by version using, for example, OSGi bundles or Java 8 Jigsaw modules. Thus, various high-level modules, their versions, and their dependencies could be managed as bundles/modules. These kinds of modules/bundles are a bit different from DDD Modules, but they can complement each other. Certainly it makes sense to bundle loosely coupled parts of a domain model into the larger-grained modules according to their DDD Modules. After all, it’s the loosely coupled design of your DDD Modules that will contribute to your ability to bundle with OSGi or modularize to Jigsaw.

> 需要注意的是，软件的当前进展正迈向一个更高层次的模块化。这种趋势将那些松耦合的，但是具有逻辑内聚性的软件分成具有版本号的部署单元。在 Java 世界中，我们依然考虑的是 JAR 这种文件格式，但是我们希望将版本号也加入其中，比如 OSGi 捆绑包（bundle）或者 Java 8 的 Jigsaw 模块。因此，众多的高层模块、它们的版本号和依赖关系都可以通过捆绑包/模块予以管理。这种模块/捆绑包和 DDD 中的模块稍有不同，但是它们之间是可以互补的。比如，根据 DDD 中的模块划分将领域模型中存在松耦合关系的各个部分封装到不同的捆绑包中是有好处的。毕竟，将你的软件封装成 OSGi 捆绑包或 Jigsaw 模块得益于 DDD 模块之间的松耦合性。

Cowboy Logic 牛仔的逻辑

LB: “You gotta wonder how this gas station keeps their restrooms so neat and clean.”

> LB：“你可能会问，这家加气站为什么能将他们的休息室打扮得如此干净整洁。”

AJ: “Now, LB, a tornado could hit that restroom and do $10,000 in improvements.”

> AJ：“LB，是因为如果这间休息室遭龙卷风袭击，那么他们可以获得 10，000 美元的补偿。”

Image

We’ll focus on how DDD Modules are used. Thinking of the purposes of specific Entities, Value Objects, Services, and Events of your model benefits Module design. Let’s look at examples of thoughtful Module design.

> 在本章中，我们主要讨论如何使用 DDD 模块。现在，思考实体、值对象、领域服务和领域事件各自的目的，这将有助于我们对模块的设计。

## 9.2 BASIC MODULE NAMING CONVENTIONS 模块的基本命名规范

In both Java and C#, the names of Modules reflect a hierarchical form.1 Each level in the hierarchy is separated by a dot/period. The name hierarchy generally begins with the name of the organization that produced it, composed with its Internet domain name. When the Internet domain name is used, it typically starts with the top-level domain, followed by the organizational domain name:

> 在 Java 和 C#中，模块都具有一种层级形式[1]。层级中不同层通过圆点分开。通常，模块名都以你自己的公司/组织名称开头，其中还包含因特网域名。在使用因特网域名时，通常以顶级域名开头，然后是你公司/组织的域名：

1. There will be some differences between Java packages and C# namespaces. If you’re developing with C#, for example, you can still use this as guidance, but you’ll want to adapt it to make sense for your specific programming language and platform.

```
com.saasovation // Java
SaaSOvation // C#
```

Using unique top-level names prevents namespace collision with third-party Modules that are employed on your projects, or those caused when yours are consumed by others. If you have questions about the most basic conventions, you can consult the standard.2

> 唯一的顶级模块名可以避免与第三方模块的命名冲突。如果你对基本的命名规范存在疑问，可以参考 Java 包的命名标准[2]。

2. http://java.sun.com/docs/books/jls/second_edition/html/packages.doc.html#26639.

Very likely your organization has already settled on a top-level Module naming convention. It’s best to be consistent.

> 很有可能的是，你的公司已经规定好了顶级模块名的命名规范，因此请保持命名规范的一致性。

## 9.3 MODULE NAMING CONVENTIONS FOR THE MODEL 领域模型的命名规范

The next segment of the Module name identifies the Bounded Context. Basing this segment on the name of the Bounded Context is a good choice.

> 接下来的一层模块名定位了一个限界上下文。在模块名中加入限界上下文的名称是有好处的。

Here is how the SaaSOvation teams named these Modules:

> 以下是 SaaSOvation 团队对三个模块的命名：

Image

```
    com.saasovation.identityaccess
    com.saasovation.collaboration
    com.saasovation.agilepm
```

They considered using the following, but it added little if any value compared to the previous Module names. Even though they exactly name the Context, they probably produce unnecessary noise:

> 在此之前，他们考虑了以下的命名方式，但是和上面的命名方式相比，价值并不大。虽然他们使用了限界上下文的全称，但是这样却有可能带来没必要的噪音：

```
    com.saasovation.identityandaccess
    com.saasovation.agileprojectmanagement
```

Interestingly, too, they did not use their commercial product names (brands) in the Module names. Brand names can change, and sometimes product names have little or no direct correlation to the underlying Bounded Contexts. It is more important to identify the Context by name since that’s what the team discusses. The goal is to reflect the Ubiquitous Language. If the team were to use the following names, it wouldn’t help them realize that goal:

> 有趣的是，他们并没有在模块名中使用商业产品名（名牌）。品牌的名字有可能改变，而有时产品名和限界上下文并没有多大的联系。因此，限界上下文的名称更加重要，因为这是团队成员们的讨论用语。使用限界上下文的名称作为模块名的目的在于反映通用语言。如果团队使用以下名称，他们并达不到反映通用语言的目的：

```
    com.saasovation.idovation
    com.saasovation.collabovation
    com.saasovation.projectovation
```

The first Module name, com.saasovation.idovation, has almost no correlation to its Bounded Context. The second one is fairly close. The third name is almost as deficient as the first, but slightly better. At least it has the word project in it. Nonetheless, the team decided that these names didn’t have an intuitively obvious mental mapping to the Bounded Contexts represented. Even more, if marketing decided that any of the product names had to change—possibly for trademark infringement or cultural incompatibilities—these Module names would be completely obsolete. So the team decided to stick with the first set.

> 第一个模块名，com.saasovation.idovation，几乎与其所在的限界上下文没有联系。第二个要稍好一点。第三个比第一个也好不到什么地方去，但至少包含有“project”一词。无论如何，SaaSOvation 的团队成员都认为，这些名字都无法与它们各自对应的限界上下文很好地匹配起来。再者，如果业务层决定更改产品的名字，那么这些模块名也将变得过时。因此，团队成员们决定采用第一种方法。

Next, they tacked on an important qualifier. It identifies that the specific Module is in the domain:

> 接下来，他们又向模块名中添加了另一层重要的名字，该层用于定位领域中某个特定的模块。

```
    com.saasovation.identityaccess.domain
    com.saasovation.collaboration.domain
    com.saasovation.agilepm.domain
```

This convention is compatible with a traditional Layers Architecture (4) and a Hexagonal Architecture (4). These days a system that uses Layers will generally manage them using a Hexagonal, injection style. With Hexagonal you have an “inside” part of the application, which includes the domain part. This will be similar with other architectural styles.

> 这种命名规范与传统的分层架构（4）和六边形架构（4）是兼容的。当下，一个使用分层的系统通常会用到六边形架构和依赖注入的风格。在使用六边形架构时，应用程序包含了一个“内在”的部分，其中包含了领域模型。这和其他架构风格相似。

The domain compartment may be devoid of interfaces/classes and serve only as a container for lower-level Modules. Here’s the next level down:

> 以上的“domain”部分可能并不直接包含实际的接口/类，而是作为更低层模块的容器。以下是“domain”的下一层：

```
com.saasovation.identityaccess.domain.model
com.saasovation.collaboration.domain.model
com.saasovation.agilepm.domain.model
```

This is where model classes start to be defined. This package level can contain reusable interfaces and abstract classes.

> 在该层中，我们定义模型中的类。接口类和抽象类也位于其中。

SaaSOvation liked to place in this Module common interfaces, such as those that were used for Event publishing, and abstract base classes for Entities and Value Objects:

> SaaSOvation 团队喜欢在该模块中放入一些通用的接口，比如那些用于发布事件的类，还有实体和值对象的抽象基类：

```
    ConcurrencySafeEntity
    DomainEvent
    DomainEventPublisher
    DomainEventSubscriber
    DomainRegistry
    Entity
    IdentifiedDomainObject
    IdentifiedValueObject
```

If you favor the style of placing Domain Services outside the domain.model Module, you can create a peer to it:

> 如果你喜欢将领域服务放在 domain.model 之外，那么你可以为其创建一个与 model 同层的模块：

```
com.saasovation.identityaccess.domain.service
com.saasovation.collaboration.domain.service
com.saasovation.agilepm.domain.service
```

It is not a requirement to place Domain Services here. It is available if you consider them to be a kind of medium-grained service mini-layer above the model, or a ring surrounding it [Evans, p. 108, “Granularity”]. However, be aware that this approach can quickly lead to Anemic Domain Model, which is discussed in Services (7).

> 当然，将领域服务放在该模块中并不是必需的。此时，我们可以将领域服务看成是位于模型之上的一个迷你层，或者是环绕模型的一层[Evans，p.108，“Granularity”]。但是，请注意，这种方式可能会导致贫血领域模型，请参考领域服务（7）。

In the case where you do not divide model and services into two packages, it is possible to drop the model Module and just place all model Modules directly under domain:

> 如果你不打算将模型和领域服务放在分离的包中，那么你也可以将所有的模型模块直接放在 domain 下：

```
com.saasovation.identityaccess.domain.conceptname
```

It does eliminate one level that may seem redundant. Yet, what happens if later you do decide to place a few Domain Services into a domain.service sub-Module? At that point you’d probably be pretty disappointed that you failed to create a domain.model sub-Module.

> 这种方式的确消除了多余的一层。但是，如果之后你又决定将一些领域服务放在 domain.service 子模块中，你该怎么办呢？那时，你可能会失望于先前没有创建 domain.model 这个子模块。

But there’s an even more important naming influence to consider. Remember that we do not develop a domain. The Domain (2) is some realm of know-how of the business we are working in. What we design and implement is a model of a domain. So when naming the ultimate Module of the model, domain.model seems most appropriate. Still, that’s the choice of your team.

> 然而，我们还需要考虑到另一个更重要的方面。请记住，我们并不是开发一个领域。领域（2）表示的是我们所工作的一个业务范围。事实上，我们开发的是一个领域中的模型。因此，在命名模型中的一个最终模块时，使用 domain.model 是最合适的。当然，这同样只是一个选择问题。

## 9.4 MODULES OF THE AGILE PROJECT MANAGEMENT CONTEXT 敏捷项目管理上下文中的模块

SaaSOvation’s current Core Domain (2) is the Agile Project Management Context, so it makes sense to see how its Modules are designed.

> SaaSOvation 公司当前正工作于敏捷项目管理核心域（2），让我们看看他们是如何设计模块的。

The ProjectOvation team chose three top-level Modules: tenant, team, and product. Here’s the first:

> SaaSOvation 的 ProjectOvation 团队选用了 3 个顶层模块：tenant、team 和 project。以下是 tenant 模块：

```
com.saasovation.agilepm.domain.model.tenant
    <<value object>> TenantId
```

Its contents are a simple Value Object, TenantId, that holds the unique identity of a specific tenant, which originates in the Identity and Access Context. In the case of this Module, just about all others in the model will depend on it. It’s essential for segregating one tenant’s objects from another’s. Yet, the dependency is acyclic. The tenant Module does not depend on the others.

> 该模块中包含了值对象 TenantId，TenantId 表示某个租户的唯一标识，该标识来自于身份与访问上下文。模型中的所有其他模块都依赖于 tenant 模块。我们需要将一个租户所对应的对象与另一个租户的对象分离开来。但是，这些模块之间的依赖是非循环依赖，即 tenant 模块并不依赖于其他模块。

The team Module holds Aggregates and a Domain Service that is used to manage product teams:

> 上面的 team 模块包含了聚合类以及一个用于管理产品团队的领域服务：

```
com.saasovation.agilepm.domain.model.team
     <<service>> MemberService
     <<aggregate root>> ProductOwner
     <<aggregate root>> Team
     <<aggregate root>> TeamMember
```

There are three Aggregates and one Domain Service interface. Class Team holds one ProductOwner instance and any number of TeamMember instances in a collection. The ProductOwner and TeamMember instances are created by the MemberService. All three of the Aggregate Root Entities reference the TenantId of the tenant Module:

> 该模块中含有 3 个聚合类和一个领域服务接口。Team 类维护了一个 ProductOwner 实例，同时还拥有一个 TeamMember 的集合。ProductOwner 和 TeamMember 实例由 MemberService 所创建。所有这三个聚合根实体都引用了 tenant 模块中的 TenantId：

```java
package com.saasovation.agilepm.domain.model.team;
import com.saasovation.agilepm.domain.model.tenant.TenantId;
public class Team extends ConcurrencySafeEntity {
    private TenantId tenantId;
    ...
}
```

The MemberService is a front end for an Anticorruption Layer (3) that synchronizes product team members with identities and roles of the Identity and Access Context. The synchronization happens in the background, out of band with regular user requests. This Service is proactive, creating members as they are registered in the remote Context. The synchronization is eventually consistent with the remote system but lags only a short period of time from actual changes that occur remotely. It also updates member details, such as names and e-mail addresses, as needed.

> 这里的 MemberService 作为防腐层（3）的前端，它的作用在于从身份与访问上下文中同步 TeamMember。同步过程采用静默方式，即不需要用户请求。当一个 TeamMember 在远程上下文中注册时，该 MemberService 将主动地调用同步方法。该同步过程与远程系统能够保持最终一致性，只是其中有短暂的时延。同时，MemberService 还用于更新 TeamMember 的细节信息，比如名字和 E-mail 地址等。

The Agile Project Management Context has a parent Module named product and three children:

> 敏捷项目管理上下文拥有一个名为 product 的父模块，它包含 3 个子模块：

```
com.saasovation.agilepm.domain.model.product
    <<aggregate root>> Product
    ...
    com.saasovation.agilepm.domain.model.product.backlogitem
        <<aggregate root>> BacklogItem
        ...
    com.saasovation.agilepm.domain.model.product.release
        <<aggregate root>> Release
        ...
    com.saasovation.agilepm.domain.model.product.sprint
        <<aggregate root>> Sprint
        ...
```

This is where the modeling of Scrum’s core lives. Here you will find Product, BacklogItem, Release, and Sprint Aggregates. You’ll see in Aggregates (10) why the concepts are modeled as separate Aggregates.

> 这是 Scrum 的核心模型所在的地方，其中有 Product、BacklogItem、Release 和 Sprint。在聚合（10）中我们将学到为什么要将不同的概念建模成不同的聚合。

Image

The team liked how the Modules read naturally per the Ubiquitous Language: “product,” “product backlog item,” “product release,” and “product sprint.”

> SaaSOvation 的团队成员们非常喜欢这种自然的模块命名方式，因为它与通用语言有很好的对应关系：“产品”、“产品待定项”、“产品发布”和“产品冲刺”。

With so few closely related Aggregates—only four—why didn’t the team place all four in the product Module? Not shown here are all the other Aggregate parts, such as the ProductBacklogItem Entity contained by Product, the Task Entity contained by BacklogItem, the ScheduledBacklogItem contained by Release, and the CommittedBacklogItem contained by Sprint. There are other Entities and Value Objects held by each Aggregate type. Too, there are a number of Domain Events published by some Aggregates. All in all, placing nearly 60 classes and interfaces in a single Module would make it quite busy, giving a definite impression of disorganization. The team opted for organization over cross-Module coupling concerns.

> 这里出现了 4 个聚合——他们为什么没有将这 4 个聚合直接放在 product 模块中呢？除了这 4 个聚合之外，还存在其他聚合，比如 Product 所包含的 ProductBacklogItem 实体、BacklogItem 所包含的 Task 实体、Release 所包含的 ScheduledBacklogItem 实体和 Sprint 所包含的 CommittedBacklogItem 实体。有些聚合还有可能发布领域事件。这些类总计起来将近 60 个，要将它们放在同一个模块中显然是不合适的。

Like ProductOwner, Team, and TeamMember, all of the Product, BacklogItem, Release, and Sprint Aggregate types reference TenantId. And there are additional dependencies. Consider Product:

> 和 ProductOwner、Team 和 TeamMember 一样，Product、BacklogItem、Release 和 Sprint 都引用了 TenantId。此外，还存在额外的依赖。比如 Product：

```java
package com.saasovation.agilepm.domain.model.product;

import com.saasovation.agilepm.domain.model.tenant.TenantId;

public class Product extends ConcurrencySafeEntity {
    private ProductId productId;
    private TeamId teamId;
    private TenantId tenantId;
    ...
}
```

Also, look at BacklogItem:

> 再看看 BacklogItem：

```java
package com.saasovation.agilepm.domain.model.product.backlogitem;

import com.saasovation.agilepm.domain.model.tenant.TenantId;

public class BacklogItem extends ConcurrencySafeEntity {
    private BacklogItemId backlogItemId;
    private ProductId productId;
    private TeamId teamId;
    private TenantId tenantId;
    ...
}
```

The references to TenantId and TeamId are acyclic dependencies; they go in a single direction. Yet, while the BacklogItem reference to ProductId seems to form an acyclic dependency from the backlogItem Module to product, it is actually bidirectional. Each Product serves as a Factory for creating BacklogItem (and Release, and Sprint) instances. Thus, the dependencies go in both directions. Still, the three sub-Modules are children of product, and we can relax the rules of dependencies a bit. Here the trade-off is organizational strengths over coupling. Again, BacklogItem, Release, and Sprint are all natural and expected child concepts of Product, so there is little sense in trying to break up these concepts beyond Aggregate boundaries.

> 对 TenantId 和 TeamId 的依赖是非循环依赖，它们都是单向的。但是，从 BacklogItem 对 ProductId 引用来看，我们似乎只是在 backlogitem 模块和 product 模块之间引入了单向依赖，而事实上它们却是双向依赖。每个 Product 都作为创建 BacklogItem（还包括 Release 和 Sprint）的工厂。因此，它们之间的依赖是双向的。这里的 3 个子模块都以 product 模块作为父模块，所以我们可以放松依赖原则。在这种情况下，我们应该优先考虑模块的组织结构，而不是松耦合性。再重申一遍，BacklogItem、Release 和 Sprint 都自然地从属于 Product，因此我们没有必要再次撕开聚合边界。

However, couldn’t the team have achieved loose coupling among these elements by the use of a generic identity type, where BacklogItem, Release, and Sprint would all refer to their Product in a nonbinding manner?

> 然而，通过继承一个通用的标识类型，它们之间是可以实现松耦合的。此时，BacklogItem、Release 和 Sprint 对 Product 的引用通过通用的 Identity 完成。

```java
public class BacklogItem extends ConcurrencySafeEntity {
    private Identity backlogItemId;
    private Identity productId;
    private Identity teamId;
    private Identity tenantId;
    ...
}
```

True, the team could have achieved looser coupling. However, it would also have opened up the potential for bugs in code where each Identity type could not be distinguished from the others.

> 诚然，在使用以上方式时，SaaSOvation 团队获得了更好的松耦合性。但是，这种做法也有可能给程序带来 bug，比如我们将无法对不同的 Identity 进行区分。

The Agile Project Management Context will continue to evolve. SaaSOvation plans to support other agile approaches and tools. Doing so will impact the current Modules, at least in driving the creation of new ones, but probably also influencing changes to existing ones. The team, having an agile mentality, was committed to refactoring Modules with due diligence.

> 敏捷项目管理上下文还将进一步发展下去。SaaSOvation 公司打算支持其他敏捷方法和工具。这将对当前的模型造成影响，至少会影响到对新模块的创建，当然，也有可能影响到对既有模块的修改。不管如何，SaaSOvation 公司的团队都决定直面挑战，勇往直前。

Next, let’s consider how Modules are used in other locations through the system’s source code.

> 接下来，让我们看看系统的其他地方是如何使用模块的。

## 9.5 MODULES IN OTHER LAYERS 其他层中的模块

Regardless of the Architecture (4) you choose, you will always have to create and name the Modules of the non-model components of your architecture. Here we discuss some options for a conventional Layered Architecture (4), but ones that can be applied with other architectural styles.

> 在不考虑架构（4）的情况下，你总需要为架构中的非模型组件创建模块并为其命名。这里，我们讨论一个分层架构（4）中的模块命名规范，当然，这些规范也可以用于其他架构风格。

In a typical Layered Architecture used for an application that sports a domain model, you’d stack the layers as follows: User Interface, Application, Domain, Infrastructure. Depending on the kinds of components in each layer, as determined by your application’s needs, the Modules within each layer will vary.

> 在一个典型的分层架构中，我们将系统分为以下不同的层：用户界面层、应用层、领域层和基础设施层。根据每层中组件的不同，它们中的模块也会不同。

To start, consider the User Interface Layer (14) and the effect of supporting RESTful resources. It is possible that your resources will be used to service a GUI and system clients, producing representational state in XML, JSON, and HTML. However, in the case of supporting a GUI, RESTful resources will not/should not create representations that include presentation layout. They will instead produce only bland representations in a variety of markup (XML, HTML) and serialization formats (XML, JSON, Protocol Buffers). All of the graphical layouts that any of the representational state might be subjected to on the client will come from a different channel. Thus, in the User Interface Layer that supports REST you may choose to have at least two Modules that could be named like this:

> 让我们首先看看用户界面层（14）和其中的 REST 资源。可能的情况是，REST 资源通过 XML、JSON 和 HTML 等数据展现形式向 GUI 和系统客户端提供服务。对于 GUI 而言，REST 资源是不会为其创建展现布局的，而只是创建一些数据标记格式（XML、HTML），另外就是创建一些序列化的数据格式（XML、JSON 和协议缓存等）。在客户端，用于图形布局的数据可能通过另外的渠道获取。因此，在支持 REST 的用户界面层中，我们至少需要两个模块：

```java
com.saasovation.agilepm.resources
com.saasovation.agilepm.resources.view
```

RESTful resources are maintained in the resources package. Pure presentation concerns are provided by components in the view sub-package (or presentation, if you prefer). Depending on the number of REST-based resources your system requires, you may have a number of sub-Modules under each primary Module. Keeping in mind that one resource provider class can support several URIs, you may have few enough resource provider classes to keep them all in the primary Module. Whether or not to further modularize them is an easy decision to make once you determine your actual resource requirements.

> REST 资源由 resources 包维护，而那些只与展现相关的数据由 view（或者称为 presentation）包中的组件提供。根据系统所需的 REST 资源数量，你可能需要在每个主模块中创建多个子模块。需要记住的是，一个资源提供类可以服务于多个 URI，你可能有多个这样资源提供类，此时可以将它们全部放在主模块中。之后，如果新的需求需要进一步为它们划分子模块，修改起来也是简单的。

The Application Layer may have other Modules, which could consist of one per service type:

> 应用层可能还有另外的模块，比如一种服务对应一个模块：

```java
com.saasovation.agilepm.application.team
com.saasovation.agilepm.application.product
...
com.saasovation.agilepm.application.tenant
```

Similar to the design principles of RESTful service resources, the services in the Application Layer are divided into sub-Modules only if it helps. In the Identity and Access Context, for example, there are only a few Application Services, and the team chose to leave them in the main Module:

> 与组织 REST 资源的原则一样，只有在需要的时候才为应用层划分子模块。比如，在身份与访问上下文中只存在为数不多的应用服务，于是 SaaSOvation 团队决定将它们置放与主模块中：

```java
com.saasovation.identityaccess.application
```

You could decide in favor of the more modularized design. That would also be fine. When you have more than a few services, perhaps half a dozen or so, it would probably help to modularize them more carefully.

> 当然，你可能会倾向于使用第一种更加模块化的设计，那也是可以的。当应用服务变多时，我们便需要仔细考虑了。

## 9.6 MODULE BEFORE BOUNDED CONTEXT 先考虑模块，再是限界上下文

We have to give careful consideration to the perceived need to divide cohesive domain model objects into separate models, or to keep them together. Sometimes the linguistics of the true, actual domain will jump out at you, and sometimes the terminology will be fuzzy. In cases where terminology is fuzzy and it is not clear if contextual boundaries should be created, first consider the possibility of keeping them together. This approach will use the thinner boundary of Module to separate, rather than the thicker one of Bounded Context.

> 对于何时应该对领域模型进行分离，何时将领域模型建模成一个整体，我们应该仔细地思考与对待。有时，通用语言可以很好地帮助我们做出正确的选择。但是另外的时候，其中的术语将变得非常含糊。在这种情况下，我们并不清楚如何划分上下文边界。此时，我们可以首先将它们放在一起，使用模块来对模型进行划分，而不是限界上下文。

This does not mean that we rarely use multiple Bounded Contexts. Boundaries between models are clearly justified, as the linguistics demand. You should take away that Bounded Contexts are not meant to be used as a substitute for Modules. Use Modules to modularize cohesive domain objects, and to separate those that are not cohesive or less cohesive.

> 但是，这并不意味着我们就应该限制对限界上下文的创建。我们应该通过通用语言的需求来划分模型边界。你应该知道，限界上下文不是用来代替模块的。使用模块的目的在于组织那些内聚在一起的领域对象，对于那些内聚性不强或者没有内聚性的领域对象来说，我们应该将它们划分在不同的模块中。

Image

## 9.7 WRAP-UP 本章小结

We’ve just considered domain model modularization, why it is important, and how it is done.

> 在本章中，我们学习了对领域模型的模块化，为什么它是重要的，以及如何创建模块。

- You noted the difference between traditional Modules and the newer deployment modularity approach.
- You learned about the importance of naming Modules per the Ubiquitous Language.
- You saw how designing Modules incorrectly, even mechanically, actually stifles modeling creativity.
- You considered how the Modules of the Agile PM Context were designed, and why certain choices were made.
- You received some helpful guidance on Modules in areas of the system outside the model.
- Finally, you got a few reminders about considering the use of Modules rather than creating new Bounded Contexts, unless the linguistics dictate the coarser-grained division.

---

> - 你学到了传统的模块和部署模块之间的不同。
> - 你学到了根据通用语言来命名模块的重要性。
> - 你学到了对模块的不当设计，或者机械式的设计将给我们的建模带来负面影响。
> - 你学到了如何设计敏捷项目管理上下文中的模块。
> - 你学到了如何为模型之外的系统创建模块。
> - 最后你了解到了：我们应该优先考虑使用模块而不是限界上下文，除非通用语言为我们展示出了明确的边界。

Next, we will take a seriously deep dive into one of the least understood modeling tools of DDD, Aggregates.

> 接下来，我们将学习 DDD 中最不容易理解的工具——聚合。
