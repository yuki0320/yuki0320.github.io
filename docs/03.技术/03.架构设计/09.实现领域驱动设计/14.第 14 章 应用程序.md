---
title: 第 14 章 应用程序
date: 2021-01-07 16:25:13
permalink: /pages/051187/
categories:
  - 技术
  - 技术文档
  - 实现领域驱动设计
tags:
  - 
---
# 第 14 章 应用程序

Any program is only as good as it is useful.

> 一个程序只有在可用时才是好的。

——Linus Torvalds

A domain model often lives at the heart of an application. The application may have a user interface that presents concepts of the domain model and allows the user to perform various actions on the model. The user interface will make use of application-level services that coordinate use case tasks, manage transactions, and assert necessary security authorizations. Further, the user interface, Application Services, and domain model will rely on enterprise platform-specific infrastructural support. The infrastructure implementation details will generally include the facilities of a component container, application management, messaging, and database.

> 领域模型通常位于应用程序的中心位置。应用程序通过用户界面向外展示领域模型的概念，并且允许用户在模型上执行各种操作。用户界面使用应用服务来协调用例任务，管理事务，并执行一些必要的安全授权。另外，用户界面、应用服务和领域模型依赖于企业级的特定平台设施的支持。这些基础设施的实现细节通常包括组件容器、应用程序管理、消息系统和数据库等。

Road Map to This Chapter 本章学习路线图

- Learn several ways to provide domain model data for the user interface to render.
- See how Application Services are implemented, and the kinds of operations they perform.
- Study ways to decouple output from Application Services and disparate client types.
- Consider why you might need to compose multiple models in the user interface, and how it’s done.
- Learn ways to use the infrastructure to provide the application’s technical implementations.

---

> - 学习用户界面渲染领域模型的几种方式。
> - 学习如何实现应用服务，以及它所提供的操作。
> - 学习将输出从应用服务中解耦的几种方式，以及不同的客户端类型。
> - 学习为什么需要在用户界面中组合多个模型，以及如何实现。
> - 学习将基础设施用于应用程序的技术实现的几种方式。

Sometimes we work on models that exist to support applications. This is true of the Identity and Access Context. SaaSOvation has seen the need to break off identity and access management concerns and form a supporting model that will also serve as a subscription-based product of its own. Even in the case of IdOvation, it will of necessity have its own administrative and self-service user interface. It’s true that Generic and Supporting Subdomains (2) will sometimes lack all the extras associated with a full application, and that’s fine. When a model exists to support another model, the supporting model may be as simple as a set of classes in a separate Module (9) that address a specialty concept and provide some algorithms.1 Other models will require at least some human user experience and application components. This chapter focuses on the latter, more complex variety.

> 有时，我们所创建的模型是用来支撑应用程序的，比如身份与访问上下文即是如此。SaaSOvation 公司认为身份与访问管理相关的功能应该单独抽取出来，并将其创建成一个支撑性的模型。同时，该模型本身也可以作为一种产品。即便对于 IdOvation 来说，它也将拥有自己的用户界面来完成一些管理和自助服务等功能。诚然，对于通用子域（2）和支撑子域（2）来说，有时它们可能缺少一个完备的应用程序所需的方方面面，但是这无妨大碍。如果一个模型被用来支撑另一个模型，那么该支撑性模型可以简单到只是一个模块（9）中的一组类而已。此时，它们可能提供一些特殊的概念，或者某些算法[1]。而对于另外的一些模型来说，它们至少需要一些人为交互和应用程序组件，这样的模型是本章的主要关注点。

1. For an example Generic Subdomain that is a stand-alone model, see Eric Evans’s “Time and Money Code Library”: http://timeandmoney.sourceforge.net/.

We are here using the term application somewhat interchangeably with system and business service. I won’t attempt to formally analyze at what point an application becomes a system, but I’d say when an application depends on other applications or services through integration, the whole solution could be called a system. Sometimes the terms application and system are used interchangeably to mean one and the same thing, where system really describes what we’d normally call an application. And a single business service that provides several or many technical service endpoints might also be called a system in a general sense. While I don’t want to muddy the waters of what makes each of these three concepts distinct, I do want to use a single term that allows me to discuss concerns and responsibilities that are common to all three.

> 这里，我们所使用的术语“应用程序”可以与“系统”和“业务服务”交替起来使用。我并不会分析一个应用程序何时将变成一个系统，但是当一个应用程序通过集成的方式依赖于其他应用程序或者服务时，整个解决方案便可以称为一个系统。有时，应用程序和系统表示的是相同的概念，即当我们说到“应用程序”时，我们也完全可以称为“系统”。另外，一个提供多个技术服务端口的业务服务通常也可以称为系统。我并不打算对这 3 个概念进行严格地区分，而是希望使用单个术语来表示它们之间的共性特征。

What’s an Application? 什么是应用程序？

To boil it down, I am using the term application to mean the finest set of components that are assembled to interact with and support a Core Domain (2) model. This generally means the domain model itself, a user interface, internally used Application Services, and infrastructural components. What exactly fits into each of those compartments will vary from application to application and will depend on the specific Architectures (4) in use.

> 我这里使用的“应用程序”表示那些支撑核心域（2）模型的组件，通常包括领域模型本身、用户界面、内部使用的应用服务和基础设施组件等。至于这些组件中应该包含些什么，这是根据应用程序的不同而不同的，并且有可能受到所用架构（4）的影响。

When an application opens up its services programmatically, the user interface is broader and includes a kind of application programming interface (API). There are different ways to open its services, but the interface is not meant for human consumption. This kind of user interface is discussed in Integrating Bounded Contexts (13). In this chapter I cover aspects of human user interfaces that are typically of the graphical variety.

> 当应用程序通过编程的方式向外提供服务时，用户界面也就随之扩大了，并且将包含一种应用程序编程接口（API）。应用程序可以通过很多种方式向外提供服务，但是此时所使用的接口并不是用于人为交互的，这种类型的用户界面已经在集成限界上下文（13）中讲到了。在本章中，我们将主要关注于用于人为交互的用户界面，比如典型的图形界面。

For this topic I try to avoid leaning toward any specific Architecture. I reflect that departure in the odd-looking diagram of Figure 14.1, which purposely adheres to no typical architecture. Dashed lines with clear arrowheads depict implementation per UML, which is a reflection of Dependency Inversion Principle (4), or DIP. Solid lines with open arrowheads indicate operation dispatching. For example, the infrastructure implements interface abstractions from the user interface, Application Services, and the domain model. It also dispatches operations to Application Services, the domain model, and the data store.

> 我将尽量避免倾向于某个特定的架构。在图 14.1 中，我们看不到与架构相关的信息。其中，虚线表示的是依赖注入原则（4），而实线则表示操作分发。比如，基础设施实现了用户界面、应用服务和领域模型中的抽象接口，同时它还将操作分发给应用服务、领域模型和数据存储。

Image

Figure 14.1. The primary application areas of concern, but without ties to any one architecture. These areas still emphasize the DIP with infrastructure dependent on abstractions of every other area.

Although it is inevitable that there will be some overlap with some architectural styles, our interest in this chapter is on what most any architecture would need to do to sustain the goals of the application. Where a specific architecture does enter the picture, I provide an acknowledgment.

> 不可避免的，图 14.1 将与某些架构风格发生重叠，但是我们这里所关注的并不在于架构，而是如何支撑一个应用程序。

It is difficult not to use the term layer, as in Layers Architecture (4). It is a useful term no matter what architectural style is being discussed. For example, consider the place where Application Services live. Whether you think of the Application Services as being in a ring around the domain model, in a hexagon encompassing the model, in a capsule hanging off a message bus, or in a layer below the user interface and above the model, it should be acceptable to use the term Application Layer to describe that conceptual place. While I try to refrain from overusing the term in this chapter, layer is helpful in labeling where components reside. This certainly does not imply that DDD is limited to existing only in a Layers Architecture.2

> 要不使用“分层”的概念是很难的，关于分层，请参考分层架构（4）。无论是哪种架构风格，“分层”都是一个非常有用的术语。比如，考虑一下应用服务所处的位置。你可以将应用服务看成是围绕着领域模型的一个环或者六边形，或者是介于用户界面和模型之间的一层，无论如何，我们都可以用“应用层”来描述这个概念性的位置。虽然在本章中我会尽量少地谈及到分层的概念，但是对于表述组件所处位置来说，分层的确是非常有用的。当然，这也并不意味着 DDD 只被限制在了分层架构中[2]。

2. See Chapter 4 for details.

I start with the user interface, move on to Application Services, and then to infrastructure. Through each of the subjects I cover where the model fits in, but I don’t delve into the model proper since that would be redundant with the remainder of the book.

> 接下来，我将首先讲到用户界面，再讲应用服务，最后是基础设施。在每一个话题中，我都会讲到对领域模型的处理，但是我并不会深入地讲解模型本身，因为本书的其他章节已经讲到了。

## 14.1 USER INTERFACE 用户界面

On the Java platform, the .NET platform, and others, there are so many human user interface frameworks that it seems neither interesting nor productive to study their advantages here.

> 在 Java、.NET 或者其他平台中，存在着大量的人工用户界面框架。但是，这里我们关注的并不是这些。

What seems best is to understand the broader categories, which fall mainly under those described in the following list. They are listed in order of “heaviness” factors, not popularity. At the time of this writing it must almost certainly be the case that the second category of Web-based rich user interface is the direction of greatest choice and will soon be influenced by HTML5. Applications of the first category, pure request-response Web user interfaces, may still be more prolific as legacy applications than Web 2.0.

> 我们要讲的是那些更加宽泛的用户界面类型，请参考下面的列表。在该列表中，首先罗列的是那些重量级的用户界面，然后是轻量级的。在我撰写本书时，第二类的基于 Web 的富用户界面是最流行的，并且还将受到 HTML 5 的影响。第一类的应用程序，采用纯粹请求-应答式的 Web 用户界面，它们将作为遗留系统继续存在。

- Pure request-response Web user interfaces, perhaps best known as Web 1.0. Frameworks such as Struts, Spring MVC and Web Flow, and ASP.NET support this category.
- Web-based rich Internet application (RIA) user interfaces, including those that use DHTML and Ajax, known as Web 2.0. Google’s GWT, Yahoo!’s YUI, Ext JS, Adobe’s Flex, and Microsoft’s Silverlight fall into this category.
- Native client GUIs (for example, Windows, Mac, and Linux desktop user interfaces) that may include the use of abstraction libraries (such as Eclipse SWT, Java Swing, or WinForms and WPF on Windows). This does not necessarily imply a heavy desktop application, but it is possible that it does. The native client GUI may access services over HTTP, for example, making the user interface the only client installed component.

---

> - 纯粹请求-应答式 Web 用户界面，也称为 Web 1.0。典型框架有 Struts、SpringMVC 和 Web Flow、ASP.NET 等。
> - 基于 Web 的富互联网应用（Rich Internet Application，RIA）用户界面，包括那些使用 DHTML 和 Ajax 的系统，也称为 Web 2.0。Google GWT、Yahoo YUI、Ext JS、Adobe Flex 和 Microsoft Silverlight 均属于这个范畴。
> - 本地客户端 GUI（比如 Windows、Mac 和 Linux 的桌面用户界面），其中包括一些类库，比如 Eclipse SWT、Java Swing、WinForm 和 WPF 等。这些类库不见得一定会导致重量级的桌面应用，但这却是有可能的。本地客户端 GUI 可以通过 HTTP 访问外部服务，比如，在只将客户端安装组件作为用户界面时便是这样。

With any of these user interface categories, a few priority questions must be answered: How do we render domain objects onto the glass? And how do we communicate user gestures back to the model?

> 对于以上任何一种用户界面，首先我们都得回答以下问题：如何将领域对象渲染到用户界面的显示中？反之，如何将用户操作反映到领域模型上？

### 14.1.1 Rendering Domain Objects 渲染领域对象

There is a fair amount of controversy and disagreement on how best to render objects of the domain model onto the user interface. The user interface regularly benefits from views of data richer than is required to accomplish the direct task. The display of extra data is necessary because it provides supporting information that users need in order to make intelligent decisions to carry out their immediate task. The extra data may also include selection options. Thus, the user interface will often need to render properties of multiple Aggregate (10) instances. This is despite the fact that in most cases a user should be performing a state-mutating task that is to be applied to just one instance of a single type of Aggregate. This situation is illustrated in Figure 14.2.

> 对于如何通过最好的方式将领域对象渲染到用户界面，业界一直存在着争论。很多时候，除了操作所需数据之外，我们还会向用户界面提供一些额外的数据。这是有好处的，因为这些额外的信息可以对用户操作起到帮助作用。这些额外数据还可以包含一些选项数据。因此，用户界面通常都需要渲染多个聚合（10）实例中的属性，尽管用户最终只会修改其中一个聚合实例，请参考图 14.2。

Image
Figure 14.2. The user interface may need to render properties of multiple Aggregate instances but submit a request to modify only a single instance at a time.

### 14.1.2 Render Data Transfer Object from Aggregate Instances 渲染数据传输对象

A popular way to tackle the problem of rendering multiple Aggregate instances to a single view is to use Data Transfer Objects [Fowler, P of EAA], or DTOs. The DTO is designed to hold the entire number of attributes that need to be displayed in a view. The Application Service (see “Application Services”) will use Repositories (12) to read the necessary Aggregate instances and then delegate to a DTO Assembler [Fowler, P of EAA] to map the attributes of the DTO. The DTO thus carries the full complement of information that needs to be rendered. The user interface component accesses each individual DTO attribute and renders it onto the view.

> 一种渲染多个聚合实例的方法便是使用数据传输对象（Data Tranfer Object，DTO）[Fowler，PofEAA]。DTO 将包含需要显示的所有属性值。应用服务通过资源库（12）读取所需的聚合实例，然后使用一个 DTO 组装器（DTOAssemble）[Fowler，P of EAA]将需要显示的属性值映射到 DTO 中。之后，用户界面组件将访问每一个 DTO 属性值，并将其渲染到显示界面中。

With this approach both reads and writes are performed through Repositories. It has the advantage of resolving any lazy-loaded collections because the DTO Assembler will directly access every part of the Aggregates that it needs to build the DTO. It also solves the specific problem where the presentation tier is physically separated from the business tier and you need to serialize data holders and transfer them over the network to another tier.

> 在这种方式中，对数据的读和写都是通过资源库完成的。这种方式的好处在于不会存在延迟加载的问题，因为 DTO 组装器会直接访问聚合中需要用来创建 DTO 的所有数据。另外的一个好处是：它可以解决展现层（Presentation Tier）和业务层（Business Tier）存在物理分离的情况，此时我们需要对数据进行序列化，然后通过网络将其传输到展现层中。

Interestingly, the DTO pattern was originally designed to deal with a remote presentation tier that consumes the DTO instances. The DTO is built on the business tier, serialized, sent over the wire, and deserialized on the presentation tier. If your presentation tier is not remote, this pattern many times leads to accidental complexity in the application’s design, as in YAGNI (“You Ain’t Gonna Need It”). This includes the disadvantage of requiring the creation of classes that sometimes closely resemble the shape of domain objects but are not quite the same. It also has the downside of instantiating additional potentially large objects that must be managed by the virtual machine (for example, JVM) when in fact they are mismatched for a single virtual machine application architecture.

> 有趣的是，DTO 模式原本就是用于在远程的展现层中显示数据的。此时，DTO 在业务层中创建，再序列化，然后通过网络发送，最后在展现层中反序列化。如果你的展现层不是远程的，那么这种模式在很多时候将给你的系统带来没有必要的复杂性，即 YAGNI（“You Ain’t Gonna Neet It”，你并不需要它）。它的缺点在于，我们需要创建一些与领域对象非常相似的类。另外，我们需要创建一些必须由虚拟机（比如 JVM）所管理的大对象，而事实上这些对象却与单虚拟机应用架构不相匹配。

Your Aggregates will need to be designed so that DTO Assemblers can query for necessary data. Think carefully about how to reveal state without revealing too much about the internal shape or structure of the Aggregates. Try to eliminate a client’s coupling to all internal parts of an Aggregate. Should you allow clients—the Assemblers in this case—to navigate deeply into Aggregates? That can be a bad idea since it tightly couples each client to a specific Aggregate implementation.

> 在使用 DTO 时，我们的聚合设计需要考虑到 DTO 组装器对聚合数据的查询。此时，我们需要慎重考虑，因为我们不应该暴露出太多的聚合内部结构。我们应该尽量将客户端从聚合的内部状态中完全解耦。你应该允许客户端——在本例中即 DTO 组装器——深度访问聚合的状态吗？这并不是一个好的主意，因为它使将客户端与聚合实现紧密地耦合起来。

### 14.1.3 Use a Mediator to Publish Aggregate Internal State 使用调停者发布聚合的内部状态

To work around the problem of tight coupling between the model and its clients, you may choose to design Mediator [Gamma et al.] (aka Double-Dispatch and Callback) interfaces to which the Aggregate publishes its internal state. Clients would implement the Mediator interface, passing the implementer’s object reference to the Aggregate as a method argument. The Aggregate would then double-dispatch to that Mediator to publish the requested state, all without revealing its shape or structure. The trick is to not wed the Mediator’s interface to any sort of view specification, but to keep it focused on rendering Aggregate states of interest:

> 要解决客户端和领域模型之间的耦合问题，我们可以使用调停者模式[Gamma etal.]，即双分派（Double-Dispatch）和回调（Callback）。此时，聚合将通过调停者接口来发布内部状态。客户端将实现调停者接口，然后把实现对象的引用作为参数传给聚合。之后，聚合双分派给调停者以发布自身状态，在这个过程中，聚合并没有向外暴露自身的内部结构。这里的诀窍在于，不要将调停者接口与任何显示规范绑定在一起，而是关注于对所感兴趣的聚合状态的渲染：

```java
public class BacklogItem ... {
    ...
    public void provideBacklogItemInterest(
             BacklogItemInterest anInterest) {
         anInterest.informTenantId(this.tenantId().id());
         anInterest.informProductId(this.productId().id());
         anInterest.informBacklogItemId(this.backlogItemId().id());
         anInterest.informStory(this.story());
         anInterest.informSummary(this.summary());
         anInterest.informType(this.type().toString());
         ...
    }

    public void provideTasksInterest(TasksInterest anInterest) {
         Set<Task> tasks = this.allTasks();
         anInterest.informTaskCount(tasks.size());
         for (Task task : tasks) {
             ...
         }
    }
    ...
}
```

The various interest providers may be implemented by other classes, much the same way that Entities (5) describe the way validation is delegated to separate validator classes.

> 不同的兴趣提供方可以通过其他类实现，这就像在实体（5）中我们把验证逻辑委派给不同的验证类一样。

Be aware that some will consider this approach completely outside the responsibility of an Aggregate. Others will consider it a completely natural extension of a well-designed domain model. As always, such trade-offs must be discussed by your technical team members.

> 请注意，有些人认为这种方式完全不应该属于聚合的职责，而还有人则认为这是对领域模型的自然扩展。一如既往地，你需要和团队成员讨论，然后做出适合于自己的选择。

### 14.1.4 Render Aggregate Instances from a Domain Payload Object 通过领域负载对象渲染聚合实例

There is an approach that provides a possible improvement when DTOs are unnecessary. This one gathers multiple whole Aggregate instances for view rendition into a single Domain Payload Object [Vernon, DPO]. DPO has motivations similar to DTO but takes advantage of the single virtual machine application architecture. It is designed to contain references to whole Aggregate instances, not individual attributes. Clusters of Aggregate instances can be transferred between logical tiers or layers by a simple Payload container object. The Application Service (see “Application Services”) uses Repositories to retrieve the necessary Aggregate instances and then instantiates the DPO to hold references to each. The presentation components ask the DPO object for the Aggregate instance references, and then ask the Aggregates for viewable attributes.

> 在没有必要使用 DTO 时，我们可以使用另一种改进方法。该方法将多个聚合实例中需要显示的数据汇集到一个领域负载对象（Domain Payload Object，DPO）中[Vernon，DPO]。DPO 与 DTO 相似，但是它的优点是可以用于单虚拟机应用架构中。DPO 中包含了对整个聚合实例的引用，而不是单独的属性。此时，聚合实例集群可以在多个逻辑层之间传输。应用服务（请参考“应用服务”一节）通过资源库获取到所需聚合实例，然后创建 DPO 实例，该 DPO 持有对所有聚合实例的引用。之后，展现组件通过 DPO 获得聚合实例的引用，再从聚合中访问需要显示的属性。

Cowboy Logic 牛仔的逻辑

LB: “If you haven’t fallen off a horse, you haven’t been ridin’ long enough.”

> LB：“如果你从来没有从马上摔下来过，那证明你骑马的时间还不够长。”

Image

This approach has the advantage of simplifying the design of objects to move clusters of data between logical tiers. The DPOs tend to be much easier to design and have a smaller memory footprint. Since the Aggregate instances must be read into memory anyway, we leverage that they already exist.

> 这种方式的优点在于，它简化了在不同逻辑层之间传输集群数据的过程。和 DTO 相比，DPO 更容易设计，并且消耗更少的内存。在创建 DPO 之前，由于聚合实例必须被读到内存中，因此之后在使用 DPO 时，这些聚合实例已经存在了。

There are a few potential negative consequences to consider. Because of the similarity to DTOs, this approach also requires Aggregates to provide a means to read their state. To avoid tightly coupling the user interface to the model, the same Mediator, Double-Dispatch, or Aggregate Root query interface, suggested previously for use by DTO Assemblers, may be employed here as well.

> 当然，这种方式也是存在一些潜在缺点的。由于 DPO 与 DTO 相似，它照样需要聚合提供一些方法以读取聚合的状态。为了避免用户界面和模型之间的紧耦合，我们可能还需要使用前一节讲到的调停者。

There’s still another situation to deal with. Since the DPO holds references to whole Aggregate instances, any lazy-loaded objects/collections are not yet resolved. There is no reason to access all needed Aggregate properties to create the Domain Payload Object. Since even read-only transactions are generally committed when the Application Service method ends, any presentation component that references unresolved lazy-loaded objects will cause an exception.3

> 此外，我们还需要处理另一种情况。由于 DPO 持有的是对整个聚合实例的引用，延迟加载的对象/集合并未被加载到内存中。在创建 DPO 时，我们没有必要访问所有所需的聚合属性。由于在应用服务的方法结束时，事务已将随之提交，之后在展现组件中访问那些延迟加载的属性时，程序将抛出异常。[3]

3. Some like to use Open Session In View (OSIV) to control transactions at the request-response level, high in the user interface. For various reason I consider OSIV harmful, but YMMV (“Your Mileage May Vary”).

To fix up necessary lazy loads we might choose an eager loading strategy, or we can use a Domain Dependency Resolver [Vernon, DDR]. This is a form of Strategy [Gamma et al.], usually employing one Strategy per use case flow. Each Strategy forces access of all Aggregate lazy-loaded properties consumed by the specific use case flow. The forced access occurs before the Application Service commits the transaction and returns the Domain Payload Object to its client. The Strategy may be hard-coded to manually access the lazy-loaded properties, or it may employ a simple expression language that describes how to introspectively and reflectively navigate through the Aggregate instances. The reflection-based navigation crawler has the advantage that it can be made to work on hidden attributes. Still, you may be happier customizing your queries to eagerly fetch objects that are normally lazy loaded, if the option is available.

> 要解决延迟加载的问题，我们可以选择即时加载，或者使用领域依赖求解器（Domain Dependency Resolver，DDR）[Vernon，DDR]。这是一种策略模式（Strategy）[Gamma et al.]，通常来说，对于每一个用例流，我们都会使用一种策略。对于某个用例流所需要的所有延迟加载的属性，对应的策略都会强制性地对其进行访问。这样的策略访问作用于应用服务提交事务并返回 DPO 之前。我们可以对这样的策略进行硬编码以手动的访问所有延迟加载的属性，或者可以使用简单的表达式语言，并通过反射的机制来访问这些属性。后者的优点在于，它可以访问那些隐藏的属性。当然，在可能的情况下，你也可以定制查询过程以即时地加载聚合属性。

### 14.1.5 State Representations of Aggregate Instances 聚合实例的状态展现

If your application provides REST-based resources as discussed in REST (4), these will need to produce state representations of domain objects for clients. It is very important to create representations that are based on use case, not on Aggregate instances. This has very similar motivations as DTOs, which also are tuned for use cases. However, it may be more accurate to think of a set of RESTful resources as a separate model in their own right—a View Model or Presentation Model [Fowler, PM]. Resist the temptation to produce representations that are a one-to-one reflection of your domain model Aggregate states, possibly with links to navigate to deeper state. Otherwise your clients will have to understand your domain model as well as the Aggregates themselves. Clients will have to be fully aware of subtleties in behaviors and state transitions, and you will lose all benefits of abstraction.

> 如果你的程序提供了 REST（4）资源，那么你便需要为领域模型创建状态展现以供客户端使用。有一点非常重要：我们应该基于用例来创建状态展现，而不是基于聚合实例。从这一点来看，创建状态展现和 DTO 是相似的，因为 DTO 也是基于用例的。然而，更准确的是将一组 REST 资源看作一个单独的模型——视图模型（ViewModel）或展现模型（Presentation Model）[Fowler，PM]。我们所创建的展现模型不应该与领域模型中的聚合状态存在一一对应的关系。否则，你的客户端便需要像聚合本身一样了解你的领域模型。此时，客户端需要紧跟领域模型中行为和状态的变化，你也随之失去了抽象所带来的好处。

### 14.1.6 Use Case Optimal Repository Queries 用例优化资源库查询

Rather than reading multiple whole Aggregate instances of various types and then programmatically composing them into a single container (DTO or DPO), you might instead use what is called a use case optimal query. This is where you design your Repository with finder query methods that compose a custom object as a superset of one or more Aggregate instances. The query dynamically places the results into a Value Object (6) specifically designed to address the needs of the use case. You design a Value Object, not a DTO, because the query is domain specific, not application specific (as are DTOs). The custom use case optimal Value Object is then consumed directly by the view renderer.

> 其读取多个聚合实例，然后再通过编程的方式将它们组装到单个容器（DTO 或 DPO）中，我们可以转而使用用例优化查询。此时，我们可以在资源库中创建一些查询方法，这些方法返回的是所有聚合实例属性的超集。查询方法动态地将查询结果放在一个值对象（6）中，该值对象是特别为当前用例设计的。请注意，你设计的是值对象，而不是 DTO，因为此时的查询是特定于领域的，而不是特定于应用程序的。这个用例优化的值对象将被直接用于渲染用户界面。

The use case optimal query approach has motivations similar to CQRS (4). However, the use case optimal query uses a Repository against the unified domain model persistence store rather than a raw database (such as SQL) query against a separate query/read store. To understand the trade-offs of this approach versus CQRS, see the related discussion under Repositories (12). Still, once you start to go down this use case optimal query path, you are so close to CQRS that it may be worth going that route instead.

> 用例优化查询的动机与 CQRS（4）相似。然而，用例优化查询依然会使用资源库，而不会直接与数据库打交道（比如使用 SQL）。要了解这两者的不同，请参考资源库（12）中的相关讨论。当然，如果你打算在用例优化查询之路上继续走下去，那么你已经离 CQRS 很近了，此时考虑转用 CQRS 也是一种不错的选择。

### 14.1.7 Dealing with Multiple, Disparate Clients 处理不同类型的客户端

What will you do if your application must support multiple, disparate clients? This may include an RIA, a graphical thick client, REST-based services, and messaging too. You probably also consider various test drivers as being different client types. Discussed in more detail a bit later, you may design your Application Services to accept Data Transformer, where each client specifies the Data Transformer type. The Application Service would double-dispatch on the Data Transformer parameter, which would produce the required data format. Here’s how the user interface side might look for a REST-based client:

> 如果你的应用程序必须支持多种不同类型的客户端，你该怎么办呢？这些客户端可能包括 RIA、图形界面、REST 服务和消息系统等。另外，各种测试也可以被认为是不同类型的客户端。此时，你的应用服务可以使用一个数据转换器（DataTransformer），然后由客户端来决定需要使用的数据转换器类型。应用层将双分派给数据转换器以生成所需的数据格式。以下是一个基于 REST 的客户端所使用的用户界面：

```java
...
CalendarWeekData calendarWeekData =
    calendarAppService
        .calendarWeek(date, new CalendarWeekXMLDataTransformer());

Response response =
    Response.ok(calendarWeekData.value())
        .cacheControl(this.cacheControlFor(30)).build();

return response;
```

Method calendarWeek() of the CalendarApplicationService accepts a Date within a given week and an implementation of interface CalendarWeekDataTransformer. The chosen implementer is class CalendarWeekXMLDataTransformer, which creates an XML document as a state representation of the CalendarWeekData. Method value() on Calendar-WeekData answers the preferred type of the given data format, which in this case is an XML document String.

> CalendarApplicationService 的 calendarWeek（）方法接受 2 个参数，一个是 Date 类型的对象，另一个是 CalendarWeekDataTransformer 接口的某个实现类对象。在该例中，实现类是 CalendarWeekXMLDataTransformer，该类为 CalendarWeekData 创建一个 XML 格式的状态展现。CalendarWeekData 的 value（）方法将以指定的数据格式返回该 CalendarWeekData 的状态展现，在本例中即为 String 格式的 XML 文档。

Admittedly the example could benefit from having the Data Transformer instance dependency injected. It’s hard-coded here to make the example easier to understand.

> 需要指出的是，对于上面的例子来说，更好的方式是对数据转换器进行依赖注入。硬编码只是为了让上面的例子更容易理解。

Among the possible implementers of CalendarWeekDataTransformer could be, for example:

> CalendarWeekDataTransformer 还可以有以下实现类：

- CalendarWeekCSVDataTransformer
- CalendarWeekDPODataTransformer
- CalendarWeekDTODataTransformer
- CalendarWeekJSONDataTransformer
- CalendarWeekTextDataTransformer
- CalendarWeekXMLDataTransformer

There is another possible approach to abstracting application output types to disparate clients that I discuss later under “Application Services.”

> 对于处理不同类型的客户端来说，还有另一种方式，对此我们将在“应用服务”一节中进行讲解。

### 14.1.8 Rendition Adapters and Handling User Edits 渲染适配器以及处理用户编辑

When you get to the point where you have your domain data and it needs to be viewed and edited by a user, there are patterns that can help you separate responsibilities. Again, there are simply too many frameworks out there and too many ways to deal with them to recommend a surefire way to deal with all of them. With some user interface frameworks you must adhere to the specific patterns that are supported. Sometimes those are good, and sometimes not so good. With others you have a bit more flexibility.

> 有时，你需要在界面中显示领域数据，并且允许用户编辑这些数据。此时，我们可以使用一些模式来帮助我们划分职责。当然，有太多的框架可以帮助我们完成这样的任务。对于有些用户界面框架来说，我们必须采用一些特定的模式。有些时候，这些模式是好的，但另外的时候就不见得了。而另外的一些框架可能更加复杂。

In whatever way your domain data is provided from Application Services—through DTOs, DPOs, or state representations—and whatever presentation framework you use, you may be able to benefit from Presentation Model.4 Its goal is to separate responsibilities between presentation and view. While it could be made to work with Web 1.0 applications, I think its strengths tend to be in favor of Web 2.0 RIA, or those with desktop clients, as described in the second and third categories listed earlier.

> 无论应用层是通过什么方式来提供领域数据的——DTO、DPO 或者状态展现——也不管你使用的是什么样的展现框架，你都可以从展现模型[4]中获益。它的目标是分离展现与显示之间的职责。虽然展现模型可以用于 Web 1.0 的应用程序，但是我认为它的长处在于 Web 2.0 的 RIA，或者桌面客户端。

4. See also Model-View-Presenter [Dolphin], which [Fowler, PM] calls Supervising Controller and Passive View.

Using this pattern, we want to make views passive in that they only manage display of data and user interface controls and do little else. There are two possible ways of view rendering:

> 在使用这种模式时，我们需要将视图设计成被动的，即它们只用于显示数据和用户界面控件。在渲染视图时，有两种方法：

1. Views render themselves based on the Presentation Model. I think this is a more natural way and eliminates coupling from the Presentation Model to the view.
2. Views are rendered by the Presentation Model. This way has test advantages but requires the Presentation Model to couple to the view.

---

> 1. 根据展现模型，视图完成自我渲染。我认为这是一种更自然的方式，并且在展现模型和视图之间完成了解耦。
> 2. 视图由展现模型进行渲染。这种方式在测试起来要容易一些，但是它却将展现模型与视图耦合起来。

The Presentation Model acts as an Adapter [Gamma et al.]. It masks the details of the domain model by providing properties and behaviors that are designed in terms of the needs of the view. This means that there is more than a thin veneer around attributes on domain objects or DTOs. It means that decisions are made in the Adapter based on the state of the model as it applies to the view. For example, enabling a specific control on the view may not have a direct relationship to any one property of the domain model but can still be derived from one or more such. Rather than requiring the domain model to specifically support the necessary view properties, it is the responsibility of the Presentation Model to derive the view-specific indicators and properties from the state of the domain model.

> 我们可以将展现模型看成是一种适配器[Gamma et al.]。它根据视图之所需向外提供属性和行为，由此隐藏了领域模型的细节。这也意味着，此时的展现模型不止是向外提供领域对象或 DTO 的属性，而是在渲染视图时，展现模型将根据模型的状态做出一些决定。比如，要在视图中显示一个特定的控件，这并不会与领域模型中的属性存在直接的关系，而是可以从这些属性中推导得出。我们不会要求领域模型对视图显示属性提供特别的支持，而是将职责分给展现模型。此时，展现模型通过领域模型的状态推导出一些特定于视图的指示器和属性值。

A further, yet perhaps subtle, benefit of using a Presentation Model is that it can adapt Aggregates that don’t support a JavaBean interface of getters to user interface frameworks that require getters. Many, if not all, of the Java-based Web frameworks require objects to provide public getters, such as getSummary() and getStory(), while the domain model design favors fluent, domain-specific expressions that closely reflect the Ubiquitous Language (1). The difference may be as simple as summary() and story() but produces a user interface framework impedance mismatch. Yet, a Presentation Model can be used to easily adapt summary() to getSummary() and story() to getStory(), eliminating tension between model and view:

> 使用展现模型的另一个好处在于，如果聚合不提供 JavaBean 所规定的 getter 方法，而用户界面框架恰恰又需要这样的 getter 方法，那么展现模型可以完成这样的适配转换工作。多数基于 Java 的 Web 框架都要求对象提供公有的 getter 方法，比如 getSummary（）和 getStory（）等，但是对领域模型的设计却倾向于使用流畅的、特定于领域的表达式来反映通用语言（1）。此时，我们将使用 summary（）和 story（）这样的方法命名，这便与用户界面框架产生了阻抗失配。此时，展现模型可以将 summary（）方法适配到 getSummary（）方法，将 story（）方法适配到 getStory（）方法，从而消除模型与视图之间的冲突：

```java
public class BacklogItemPresentationModel
       extends AbstractPresentationModel {
    private BacklogItem backlogItem;

    public BacklogItemPresentationModel(BacklogItem aBacklogItem) {
        super();
        this.backlogItem = backlogItem;
    }

    public String getSummary() {
        return this.backlogItem.summary();
    }

    public String getStory() {
        return this.backlogItem.story();
    }
    ...
}
```

Of course, a Presentation Model can adapt between any number of the previously discussed approaches, including the use of a DTO or DPO, or using a Mediator through which Aggregate internal state is published.

> 当然，展现模型可以对先前所讲的任何一种方式进行适配，包括 DTO、DPO，或者用于发布聚合内部状态的调停者。

Additionally, edits performed by the user are tracked by the Presentation Model. This is not a case of placing overloaded responsibilities on the Presentation Model, since it is meant to adapt in both directions, model to view and view to model.

> 此外，展现模型还可以跟踪用户的编辑。这并不是向展现模型添加更多的职责，因为它本来就应该具有双向的适配功能，从模型到视图，再从视图到模型。

One important point to keep in mind is that a Presentation Model is not a heavy-lifting Facade [Gamma et al.] around the Application Services or the domain model. Granted, once users have completed a task with the user interface, they will usually invoke an “apply” or “cancel” type of action, or preferably an explicit command. This will require the Presentation Model to reflect the user’s action to the application, which in essence represents a minimal Facade around an Application Service:

> 有一点需要注意的是，展现模型并不是围绕着应用服务或者领域模型的一个重量级门面[Gamma et al.]。诚然，当用户通过用户界面完成某个任务之后，它们通常会调用诸如“应用”或“取消”之类的操作。此时，展现模型应该能反映出这样的操作过程，即围绕着应用服务的一个最小化门面：

```java
public class BacklogItemPresentationModel
       extends AbstractPresentationModel {
    private BacklogItem backlogItem;
    private BacklogItemEditTracker editTracker;

    // following is injected
    private BacklogItemApplicationService backlogItemAppService;

    public BacklogItemPresentationModel(BacklogItem aBacklogItem) {
        super();
        this.backlogItem = backlogItem;
        this.editTracker = new BacklogItemEditTracker(aBacklogItem);
    }
    ...
    public void changeSummaryWithType() {
        this.backlogItemAppService
            .changeSummaryWithType(
                this.editTracker.summary(),
                this.editTracker.type());
    }
    ...
}
```

The user clicks a command button on the view that causes change-SummaryWithType() to be invoked. It is the responsibility of Backlog-ItemPresentationModel to interact with an Application Service to apply the edits that occurred on editTracker. There is no other bystander waiting to take the user’s edits and do something with them. So we might say that the Presentation Model is a minimal Facade to the Application Services on behalf of the view, but just because changeSummaryWithType() is a higher-level interface that makes BacklogItemApplicationService easier to use. However, we would not want to see several lines of code in the Presentation Model class manage detailed use of the Application Service, or worse yet, to itself act as the Application Service to the domain model. That would go well beyond the responsibility of the Presentation Model. Instead, we want to see a simple delegation to the more complex and heavy-lifting Facade, BacklogItemApplicationService.

> 在视图中，在用户单击命令按钮之后，changeSummaryWithType（）方法将被调用。对于 editTracker 所跟踪的编辑修改，BacklogItemPresentationModel 将负责于应用服务交互以应用这些修改。在这个过程中，没有另外的旁观者来等待用户的编辑并做相应的操作。因此，我们可以认为，展现模型代表着视图向应用服务提供了一个最小化的门面，即作为高层接口的 changeSummaryWithType（）方法使得对 BacklogItemApplicationService 的使用变得更加简单。但是，我们不应该在展现模型中出现使用应用服务的细节，或者甚至直接将展现模型本身作为领域模型的应用服务。我们希望看到的是，在展现模型中简单地将处理逻辑委派给更复杂、更重量级的门面：BacklogItemApplicationService。

This is a powerful approach to coordinating the domain model and UI. It may even receive your vote for the most versatile UI management pattern. Using any of the view management techniques, however, we still often interact with an Application Services API.

> 以上这种方式可以很好地协调领域模型和用户界面。我们甚至可以将它看作是最强大的用户界面管理模式。但是，对于任何一种视图管理技术来说，我们依然会经常与应用服务 API 交互。

## 14.2 APPLICATION SERVICES 应用服务

In some cases your user interface will aggregate multiple Bounded Contexts (2) using independent Presentation Model components, all composed on a single view. Whether your user interface renders a single model or composes multiple models, it will likely interact with Application Services, so let’s consider those now.

> 在有些情况下，用户界面将使用独立的展现模型组件来汇集多个限界上下文（2），然后将汇集后的数据组合到单个视图中。无论你的用户界面渲染了单个模型还是多个，它都需要和应用服务交互。

The Application Services are the direct clients of the domain model. For options on the logical location of Application Service, see Architecture (4). These are responsible for task coordination of use case flows, one service method per flow. When using an ACID database, the Application Services also control transactions, ensuring that model state transitions are atomically persisted. I discuss transaction control here briefly, but see Repositories (12) for a broader perspective. Security is also commonly cared for by Application Services.

> 应用服务是领域模型的直接客户。至于我们可以将应用服务放在什么样的逻辑位置，请参考架构（4）。应用服务负责用例流的任务协调，每个用例流对应了一个服务方法。在使用 ACID 数据库时，应用服务还负责控制事务以确保对模型修改的原子提交。在本节中，我只会简要地讨论到事务控制，更多的讨论请参考资源库（12）。另外，应用服务还会处理和安全相关的操作。

It is a mistake to consider Application Services to be the same as Domain Services (7). They are not. The contrast should be stark, which is clearly demonstrated in the next section. We should strive to push all business domain logic into the domain model, whether that be in Aggregates, Value Objects, or Domain Services. Keep Application Services thin, using them only to coordinate tasks on the model.

> 将应用服务与领域服务（7）等同起来是错误的。它们并不相同，我们将在下文中讨论到它们之间的区别。我们应该将所有的业务领域逻辑放在领域模型中，不管是聚合、值对象或者领域服务；而将应用服务做成很薄的一层，并且只使用它们来协调对模型的任务操作。

### 14.2.1 Sample Application Service 示例应用服务

Let’s take a look at the partial sample interface and implementation class for an Application Service. This is the service that provides use case task management for tenants of the Identity and Access Context. It is just a sample and not meant to be taken as the final say. Trade-offs will be apparent.

> 让我们来看看应用服务的一个示例接口和实现类，该应用服务用于管理身份与访问上下文中的 Tenant。这只是一个示例，而不是最终的解决方案。

First consider the basic interface:

> 首先是应用服务的接口：

```java
package com.saasovation.identityaccess.application;

public interface TenantIdentityService {
    public void activateTenant(TenantId aTenantId);

    public void deactivateTenant(TenantId aTenantId);

    public String offerLimitedRegistrationInvitation(
            TenantId aTenantId,
            Date aStartsOnDate,
            Date anUntilDate);

    public String offerOpenEndedRegistrationInvitation(
            TenantId aTenantId);

    public Tenant provisionTenant(
            String aTenantName,
            String aTenantDescription,
            boolean isActive,
            FullName anAdministratorName,
            EmailAddress anEmailAddress,
            PostalAddress aPostalAddress,
            Telephone aPrimaryTelephone,
            Telephone aSecondaryTelephone,
            String aTimeZone);

    public Tenant tenant(TenantId aTenantId);
    ...
}
```

These six Application Service methods are used to create or provision a tenant, to activate and deactivate an existing one, to offer limited and open-ended registration invitations to future users, and to query for a specific tenant.

> 以上 6 个应用服务方法用于创建 Tenant、激活和禁用已有 Tenant、邀请其他 Tenant 和查询 Tenant 等。

Some types from the domain model are used in these method signatures. That will require the user interface to be aware of these types and depend on them. Sometimes the Application Services are designed to completely shield the user interface from all such domain knowledge. Doing so, the Application Service method signatures use only primitive types (int, long, double), Strings, and possibly DTOs. As an alternative to these approaches, however, a better approach may be to design Command [Gamma et al.] objects instead. There is not necessarily a right or wrong way. It mostly depends on your tastes and goals. This book presents each of these styles in various examples.

> 领域模型中的有些对象类型被用于这些方法的签名中，这意味着用户界面需要知道这些类型，并且依赖于它们。有时，应用服务被设计成将用户界面完全地隔离于领域模型。此时，应用服务中的方法签名中将只出现原始类型（int、long 和 double 等）和 String 类型，有可能还有 DTO。但是，更好的方法是使用命令[Gamma etal.]对象。当然，这里并不存在对错之分，更多的是有关你自己的口味和目标。在本书中，我们对每一种风格都提供了示例展示。

Consider the trade-offs. If you eliminate types from the model, you avoid dependency and coupling, but you lose out on strong type checking and basic validations (guards) that you get for free from Value Object types. If you don’t expose domain objects as return types, you will need to provide DTOs. If you provide DTOs, there may be accidental complexity in your solution from the extra overhead of the additional types. Then there is also the aforementioned memory overhead in high-traffic applications that is caused by the possibly unnecessary DTOs constantly being created and garbage collected.

> 在不使用模型中的对象类型时，我们避免了依赖和耦合，但是却失去了强类型检查和基本的验证。在不把领域对象作为返回类型的情况下，我们则需要提供 DTO。此时，我们需要创建一些额外的类型，从而有可能增加系统的复杂性。另外，由于系统不断地对 DTO 进行创建和垃圾回收，这有可能还会导致不必要的内存耗费。

Of course, if you expose domain objects to disparate clients, each client type will need to deal with them separately. Again, coupling is higher and with more client types this becomes a bigger issue. Given that, at least a few of these methods could be better designed to deal with return types. As discussed previously, we might instead use Data Transformers:

> 如果你将领域对象暴露给不同类型的客户端，那么每种客户端都需要单独地处理这些对象类型。因此，在这种情况下，耦合问题将更加严重。要解决这样的问题，我们至少可以对部分服务方法进行改进。正如之前所讨论的，我们可以使用数据转换器作为返回类型：

```java
package com.saasovation.identityaccess.application;

public interface TenantIdentityService {
    ...
    public TenantData provisionTenant(
            String aTenantName,
            String aTenantDescription,
            boolean isActive,
            FullName anAdministratorName,
            EmailAddress anEmailAddress,
            PostalAddress aPostalAddress,
            Telephone aPrimaryTelephone,
            Telephone aSecondaryTelephone,
            String aTimeZone,
            TenantDataTransformer aDataTransformer);

    public TenantData tenant(
            TenantId aTenantId,
            TenantDataTransformer aDataTransformer);
    ...
}
```

For now I will stick with exposing domain objects to the client and assume that we have only one user interface that is Web based. It will help to simplify the examples. Later I’ll go back to the Data Transformers approach.

> 就现在而言，我只会讨论向客户端暴露领域对象的情况，并且假设只存在一个基于 Web 的用户界面，因为这样可以简化示例代码。之后，我们会回过头来讨论使用数据转换器的方式。

Consider how the Application Service interface is implemented. Taking a look at a few of the more trivial methods to implement it helps highlight some basic points. Note that there may be no advantage to having a Separated Interface [Fowler, P of EAA]. Here is an example where we will just define the interface with the implementation class:

> 考虑一下如何实现应用服务。让我们先看看一些简单的例子，它们有助于我们了解一些基本概念。需要注意的是，使用独立接口[Fowler，P of EAA]并没有多少好处。在下面的例子中，我们将应用服务的接口和实现定义在了同一个类中：

```java
package com.saasovation.identityaccess.application;

public class TenantIdentityService {
    @Transactional
    public void activateTenant(TenantId aTenantId) {
        this.nonNullTenant(aTenantId).activate();
    }

    @Transactional
    public void deactivateTenant(TenantId aTenantId) {
        this.nonNullTenant(aTenantId).deactivate();
    }
    ...
    @Transactional(readOnly=true)
    public Tenant tenant(TenantId aTenantId) {
        Tenant tenant =
            this
                .tenantRepository()
                .tenantOfId(aTenantId);
        return tenant;
    }

    private Tenant nonNullTenant(TenantId aTenantId) {
        Tenant tenant = this.tenant(aTenantId);
        if (tenant == null) {
            throw new IllegalArgumentException(
                    "Tenant does not exist.");
        }
        return tenant;
    }
}
```

A client requests to deactivate an existing Tenant using deactivate-Tenant(). To interact with the actual Tenant object we need to retrieve it from its Repository using its TenantId. Here we have created an internal helper method named nonNullTenant(), which itself delegates to tenant(). The helper exists to guard against nonexistent Tenant instances and is used by all service methods that need to get an existing Tenant.

> 客户端通过调用 deactivateTenant（）方法来禁用一个已有的 Tenant。要与实际的 Tenant 交互，我们需要首先通过 TenantId 从资源库中获取到一个 Tenant 实例。这里我们创建了一个内部的帮助方法 nonNullTenant（）来获取一个 Tenant，该方法进而委派给 tenant（）方法。这个帮助方法对那些 Tenant 不存在的情况起到了守卫的作用，所有的服务方法都将通过该方法来获取一个已有的 Tenant。

Methods activateTenant() and deactivateTenant() are marked write transactional by a Spring Transactional annotation. Method tenant() is marked read-only transactional. In all three cases, when a client obtains this bean through its Spring context and invokes a service method, a transaction is started. When the method completes by normal return, the transaction is committed. Depending on configuration, exceptions thrown within the scope of the method will cause the transaction to roll back.

> 方法 activateTenant（）和 deactivateTenant（）被标记以 Spring 的 Transactional 事务注解，并且是可写事务；而 tenant（）方法的事务则是只读的。在所有这三种情况下，当客户端从 Spring 容器中获取到该 TenantIdentityService 并调用服务方法时，事务便会启动。当这些方法正常返回时，事务将被提交。根据不同的配置，从方法中抛出的异常将导致事务的回滚。

But how would we prevent the misuse of these methods, say, by a malicious intruder? When we are talking about deactivating or reactivating a tenant, it’s an operation that should actually be permitted only by an SaaSOvation employee authorized user. The same goes for provisioning a new tenant subscriber.

> 但是，我们如何保证这些方法不被错误地调用呢？比如，来了一个恶意的攻击方？当我们谈论到激活或禁用一个 Tenant 时，这样的操作实际上只能由 SaaSOvation 公司通过授权的员工用户完成。对于准备（Provision）一个新的 Tenant 订阅方来说，也是一样。

What if we were to leverage something like Spring Security? We could use another annotation, PreAuthorize:

> 此时，我们可以使用 Spring Security。我们需要另一个注解，PreAuthorize：

```java
public class TenantIdentityService {
    @Transactional
    @PreAuthorize("hasRole('SubscriberRepresentative')")
    public void activateTenant(TenantId aTenantId) {
        this.nonNullTenant(aTenantId).activate();
    }

    @Transactional
    @PreAuthorize("hasRole('SubscriberRepresentative')")
    public void deactivateTenant(TenantId aTenantId) {
        this.nonNullTenant(aTenantId).deactivate();
    }
    ...
    @Transactional
    @PreAuthorize("hasRole('SubscriberRepresentative')")
    public Tenant provisionTenant(
            String aTenantName,
            String aTenantDescription,
            boolean isActive,
            FullName anAdministratorName,
            EmailAddress anEmailAddress,
            PostalAddress aPostalAddress,
            Telephone aPrimaryTelephone,
            Telephone aSecondaryTelephone,
            String aTimeZone) {
        return
            this
                .tenantProvisioningService
                .provisionTenant(
                        aTenantName,
                        aTenantDescription,
                        isActive,
                        anAdministratorName,
                        anEmailAddress,
                        aPostalAddress,
                        aPrimaryTelephone,
                        aSecondaryTelephone,
                        aTimeZone);
    }
    ...
}
```

This is declarative method-level security and prevents unauthorized users from accessing Application Services. Of course, the user interface would be designed to hide any navigation access to such facilities if the user were not authorized. That wouldn’t stop a malicious attacker, however, but the security declaration will.

> 这是一种声明式的、方法层面的安全授权，它可以阻止未授权的用户对应用服务的访问。当然，对于未被授权的用户来说，用户界面可以隐藏那些能够导航到应用服务的相关信息。但是，对于恶意的攻击者来说，隐藏是无济于事的，而上面的安全注解则能提供防卫。

This declarative method security is different from what IdOvation is providing. SaaSOvation employees would log in to IdOvation differently from tenant users. Particularly those with the special role SubscriberRepresentative would be permitted to execute these sensitive methods, and no subscriber user would ever be permitted to. This, of course, would require integration between IdOvation and Spring Security.

> 这种声明式的安全机制和 IdOvation 提供的安全机制是不同的。SaaSOvation 的员工登录 IdOvation 的方式与 Tenant 用户是不一样的。特别地，那些拥有 SubscriberRepresentative 角色的员工是可以执行这些敏感的服务方法的，而对于订阅方的用户来说，则不可以。当然，这需要在 IdOvation 和 Spring Security 之间进行集成。

Now, when we look at the implementation of provisionTenant(), we see that it delegates to a Domain Service. This highlights the difference between the two kinds of services, especially when we peek inside the domain Tenant-ProvisioningService. There is significant domain logic inside this Domain Service, but very little in the Application Service. Consider what the Domain Service does (although I don’t present the code here):

> 现在，让我们看看 provisionTenant（）方法，该方法将委派给领域服务。这也向我们展示了应用服务和领域服务的区别，特别是当我们看到 TenantProvisioningService 领域服务的内部时，这种区别就更加明显了。在领域服务中，存在着大量的领域逻辑，但是对于应用服务则不然。我们可以设想一下以上领域服务所完成的操作（没有提供代码）：

1. Instantiates a new Tenant Aggregate and adds it to its Repository.
2. Assigns a new administrator for the new Tenant. This includes provisioning the Administrator role for the new Tenant and publishing Event TenantAdministratorRegistered.
3. Publishes the Event TenantProvisioned.

---

> 1. 实例化一个新的 Tenant 聚合，并将其添加到资源库中。
> 2. 为该 Tenant 指派一个新的管理员，其中包括为这个新的 Tenant 准备一个 Administrator 角色，并且发布 TenantAdministratorRegistered 事件。
> 3. 发布 TenantProvisioned 事件。

If the Application Service were to do more than step 1, we would be seriously leaking domain logic out of the model. Since there are two additional steps that are not the responsibility of the Application Service, we instead place all three inside the Domain Service. Using the Domain Service, we place this “significant process . . . in the domain” [Evans].5 We also properly follow the definition of Application Service by managing the transaction, security, and the task of delegating this significant tenant provisioning process to the model.

> 如果应用服务所包含的已经超出上面的第 1 步，那么此时领域逻辑便会从模型中泄露出去。对于第 2 步和第 3 步来说，由于它们并不属于应用服务的职责，因此我们干脆将所有 3 个步骤一起放在领域服务中。在使用领域服务时，我们“将这个显著的过程.……放在了领域模型中[Evans]。[5]”同时，应用层依然管理着事务、安全和任务委派等操作，即将这个显著的准备 Tenant 的过程委派给了领域模型。

5. See Chapter 7.

But consider for a moment the noise caused by the provisionTenant() parameter list. There is a total of nine parameters, and that’s probably at least a few too many. We can prevent this situation by designing simple Command [Gamma et al.] objects instead: “Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.” In other words, we might think of a Command object as a serialized method invocation, and in our case we are interested in everything a Command can help with except for undo operations. This is how simple a Command class is to design:

> 但是，请注意 provisionTenant（）方法的参数列表。这里总共有 9 个参数，并且还可能存在更多。对于这样的情况，我们可以通过一个简单的命令[Gamma et al.]对象予以避免。命令对象即“将一个请求封装到一个对象中，从而使得我们对客户端进行参数化，包括不同的请求、队列或者日志请求等；另外，命令对象还支持撤销操作。”换句话说，我们可以将命令对象看成是序列化的方法调用。在本例中，除了撤销操作，我们希望得到命令对象所带来的所有其他好处。以下是一个简单的命令类：

```java
public class ProvisionTenantCommand {
    private String tenantName;
    private String tenantDescription;
    private boolean isActive;
    private String administratorFirstName;
    private String administratorLastName;
    private String emailAddress;
    private String primaryTelephone;
    private String secondaryTelephone;
    private String addressStreetAddress;
    private String addressCity;
    private String addressStateProvince;
    private String addressPostalCode;
    private String addressCountryCode;
    private String timeZone;

    public ProvisionTenantCommand(...) {
        ...
    }

    public ProvisionTenantCommand() {
        super();
    }

    public String getTenantName() {
        return tenantName;
    }

    public void setTenantName(String tenantName) {
        this.tenantName = tenantName;
    }
    ...
}
```

The ProvisionTenantCommand doesn’t use model objects, just basic types. It has a multi-argument constructor and also a zero-argument constructor. Along with the zero-argument constructor, having public setters allows the Command to be populated by UI form-field-to-object mappers (for example, assuming a JavaBean, or .NET CLR properties). You might think of the Command as a DTO, but it is truly more than that. Since the Command object is named for the operation that is to be carried out, it is more explicit. The Command instance may be passed to an Application Service method:

> 这里的 ProvisionTenantCommand 并没有使用领域对象，而是一些基本的类型。它拥有一个多参数的构造函数和一个没有参数的构造函数。公有的 setter 方法使得我们将 UI 中的字段映射到相应的 ProvisionTenantCommand 属性中（比如，考虑使用 JavaBean 或者.NET CLR 属性）。你可以将命令对象看成是一个 DTO，但是，命令对象所能表达的要比 DTO 多。由于我们根据操作来命名命令对象，它的意图将更加明显。我们可以将命令对象的实例传给应用服务的方法：

```java
public class TenantIdentityService {
    ...
    @Transactional
    public String provisionTenant(ProvisionTenantCommand aCommand) {
        ...
        return tenant.tenantId().id();
    }
    ...
}
```

Besides this approach of dispatching to an Application Service API method, as the pattern states we could instead or in addition to send Commands to a queue to be dispatched to a Command Handler. Consider a Command Handler to be semantically equivalent to an Application Service method, but temporally decoupled. As discussed in Appendix A, this enables greater throughput and scalability of Command handling.

> 在上例中，我们把一个命令对象分发给了应用服务的 API 方法。除此之外，我们还可以将命令对象发送到一个队列中，然后分发给命令处理器（CommandHandler）。我们可以将命令处理器等效于应用服务的方法，但是它的好处在于可以做到临时的解耦。在附录 A 中我们会讨论到，这种方法可以获得更大的吞吐量，并且可以增加命令处理的伸缩性。

### 14.2.2 Decoupled Service Output 解耦服务输出

A couple of times earlier I discussed the use of Data Transformers as a way to accommodate disparate client types with the specific data type they require. That approach uses Transformers to produce the data in a specific type that implements an abstract interface that all related types share. Again, from the client’s perspective it might look like this:

> 先前，我们讨论到了数据转换器。对于不同类型的客户端，数据转换器将提供客户端所需的特定数据类型。此时，不同的数据转换器将实现一个共有的抽象接口。从客户端的角度，我们可以通过以下方式来使用数据转换器：

```java
TenantData tenantData =
    tenantIdentityService.provisionTenant(
            ..., myTenantDataTransformer);

TenantPresentationModel tenantPresentationModel =
    new TenantPresentationModel(tenantData.value());
```

The Application Services are designed as an API, with input and output. The reason for passing in a Data Transformer is to produce the specific output type needed by the client.

> 应用服务被设计成了具有输入和输出的 API，而传入数据转换器的目的即在于为客户端生成特定的输出类型。

What if we took an entirely different course and made the rule that Application Services are always declared void and, thus, never return data to clients? How would that work? The answer lies in a mentality that the Hexagonal Architecture (4) promotes, the use of the Ports and Adapters style. In this instance we would use a single standard output Port with any number of adapters, one for each client type. Doing so would yield a provisionTenant() Application Service method like this one:

> 现在，让我们考虑另一种完全不同的方式：使应用服务返回 void 类型而不向客户端返回数据。这将如何工作呢？事实上，这正是六边形架构（4）所提倡的，此时我们可以使用端口和适配器的风格。对于本例，我们可以使用单个标准输出端口，然后为不同种类的客户端创建不同的适配器。此时，应用层的 provisionTenant（）方法将变成：

```java
public class TenantIdentityService {
    ...
    @Transactional
    @PreAuthorize("hasRole('SubscriberRepresentative')")
    public void provisionTenant(
            String aTenantName,
            String aTenantDescription,
            boolean isActive,
            FullName anAdministratorName,
            EmailAddress anEmailAddress,
            PostalAddress aPostalAddress,
            Telephone aPrimaryTelephone,
            Telephone aSecondaryTelephone,
            String aTimeZone) {
        Tenant tenant =
            this
                .tenantProvisioningService
                .provisionTenant(
                        aTenantName,
                        aTenantDescription,
                        isActive,
                        anAdministratorName,
                        anEmailAddress,
                        aPostalAddress,
                        aPrimaryTelephone,
                        aSecondaryTelephone,
                        aTimeZone);
        this.tenantIdentityOutputPort().write(tenant);
    }
    ...
}
```

The output Port here is a specific named Port at the edge of the application. Using Spring, it would be a bean injected into the service. The only thing that provisionTenant() needs to know is that it must write() to the Port the Tenant instance it gets from the Domain Service. This Port would have any number of readers, which register themselves ahead of using the Application Service. When a write() occurs, each of the registered readers is signaled to read the output as its input. At that point the readers may transform the output using the established mechanism, such as a Data Transformer.

> 这里的输出端口是一个特殊的命名端口，它位于应用程序的边缘。在使用 Spring 时，该端口类可以被注入到应用服务中。此时，provisionTenant（）方法唯一需要知道的便是调用 write（）方法把从领域服务中获取到的 Tenant 实例写到端口中。该端口可以有很多读取器，在使用应用服务之前，我们将这些读取器注册给端口。在 write（）方法执行后，每一个注册的读取器都会将端口的输出作为自己的输入。在读取数据时，读取器可以使用某些机制对数据进行转换，比如数据转换器。

This isn’t just a fancy artifice to add complexity to your architecture. The strength is the same as with any Ports and Adapters architecture, whether for a software system or a hardware device. Each component only needs to understand the input it reads, its own behavior, and the Port to which it writes output.

> 这并不是一种增加架构复杂性的雕虫小技，而是与其他任何端口和适配器架构——无论是软件系统，还是硬件设备——具有相同的长处。每一个组件只需要知道读进输入、调用自身行为，最后将输出写到端口中。

Writing to a Port is roughly the same thing that an Aggregate pure command method does when it produces no return value, but it does publish a Domain Event (8). In the case of the Aggregate the Domain Event Publisher (8) is an Aggregate output Port. Further, if we solve querying the state of an Aggregate by using a Double-Dispatch on a Mediator, it is similar to using Ports and Adapters.

粗略看来，将输出写到端口中与聚合中的纯命令方法相似。聚合的这些命令方法也没有返回值，但是它却会发布领域事件（8）。因此，对于聚合来说，事件发布器便是输出端口。另外，如果我们使用调停者的双分派来处理对聚合状态的查询，那么这也与端口和适配器相似。

One downside of the Ports and Adapters approach is that it may make it more difficult to name Application Service methods that perform queries. Consider method tenant() from the sample service. That name now seems inappropriate because it no longer answers the Tenant that it queries. The name provisionTenant() still works for the provisioning API because it actually becomes a pure command method, no longer returning a value. But we might want to think of a better name for tenant(). The following may improve things a bit:

> 使用端口和适配器的一个不足之处在于，我们很难命名应用服务中的查询方法。考虑一下上面示例中的 tenant（）方法。此时，该方法的名字已经不再合适，因为它不再返回 Tenant 实例。但是，provisionTenant（）方法的名字则可以保持不变，因为它已经变成了一个纯命令方法，而不需要返回值。那么，对于 tenant（）方法来说，我们应该给它起一个更好的名字：

```java
    ...
    @Override
    @Transactional(readOnly=true)
    public void findTenant(TenantId aTenantId) {
        Tenant tenant =
            this
                .tenantRepository
                .tenantOfId(aTenantId);
        this.tenantIdentityOutputPort().write(tenant);
    }
    ...
}
```

The name findTenant() might work because finding doesn’t necessarily imply the need to answer a result. Whatever name is chosen, the situation confirms that each architectural decision we make leads to positive and negative consequences.

> 这里的 findTenant（）方法是合理的，因为查找并不隐含需要返回结果的意思。但是，无论如何，我们都知道了：任何一种架构都同时存在正面的和负面的影响。

## 14.3 COMPOSING MULTIPLE BOUNDED CONTEXTS 组合多个限界上下文

The examples I have provided don’t address the possibility that a single user interface may need to compose two or more domain models. In my examples, concepts from upstream models are integrated into downstream models by translating them into terms of the downstream model.

> 在以上的例子中，我们并没有谈及到单个用户界面需要多个领域模型提供数据的情况。在这种情况下，上游模型中的概念被集成到了下游模型中，采用的方法是将上游的概念翻译成下游模型中的术语。

That’s different from the need to compose multiple models into one unified presentation, as seen in Figure 14.3. The foreign models, in this example, are Products Context, Discussions Context, and Reviews Context. The user interface should not be aware that it is composing multiple models. When a similar situation occurs in your application, you should give thought to how Module (9) structure and naming support your needs, and how Application Services can smooth out the probable disconnect between different models.

> 这和图 14.3 中所展示的是不同的。在图 14.3 中，我们需要将多个模型组合成一个单一的展现。图中的产品上下文（Products Context）、讨论上下文（DiscussionContext）和检查上下文（Review Context）都属于外部模型。如果这样的场景出现在你自己的应用程序中，那么你需要好好考虑如何设计模块（9）结构并对其命名，以及在应用服务中如何平滑地处理不同模型之间的摩擦。

Image

Figure 14.3. There are times when a UI must compose multiple models. Here three models are composed using a single Application Layer.

One solution uses multiple Application Layers, which is unlike that shown in Figure 14.3. With multiple Application Layers you would need to supply independent user interface components with each, where the user interface components would have some affinity to a specific underlying domain model. This is basically the portal-portlet style. Still, it could be more difficult to get the disparate Application Layers and independent user interface components to harmonize along use case flows, which is what the user interface is concerned with.

> 一种方式是采用多个应用层，这种方式与图 14.3 中所示的不同。在这种方式中，我们需要为每个用户界面组件都提供所有的应用层，此时的用户界面组件将向领域模型靠近。基本上，这只是一种 Portal-Portlet 的风格而已。另外，这种方式也无法与用例流保持一致，而这却正是用户界面所关注的。

Since the Application Layer manages use cases, it may be easiest to create a single Application Layer as the actual source of model composition, which is the approach shown in Figure 14.3. Services in that single layer are devoid of business domain logic. It will only serve to aggregate objects from each model into cohesive ones that the user interface needs. Likely in this case you would name Modules in the User Interface and Application Layers according to the purpose of the composition, a named context:

> 由于是应用层来管理用例，此时最简单的方法可能是创建一个单一的应用层，并使该应用层来组合多个模型，如图 14.3 所示。另外，又由于这个应用层中的服务并不包含领域逻辑，它的唯一功能便是将不同模型中的聚合对象组合成用户界面所需的内聚对象。在这种情况下，我们可以根据数据组合的目的来命名用户界面和应用层中的模块：

```java
com.consumerhive.productreviews.presentation

com.consumerhive.productreviews.application
```

Consumer Hive provides consumer product reviews and discussions. It has separated the Products Context from the Discussions Context and Reviews Context. Yet, the presentation and application Modules reflect the unification under one user interface. Likely it gets its product catalog from one or more external sources, whereas the discussions and reviews are its Core Domain.

> 这里的 Consumer Hive 向外提供产品检查和讨论。它把产品上下文从讨论上下文和检查上下文中分离出来。但是，presentation 和 application 模块表明它们位于同一个用户界面之下。虽然该用户界面将从多个外部源中获取产品目录，但是这无妨大碍，因为讨论和检查才是它的核心域。

And speaking of Core Domain . . . Strangely enough, what do you detect here? Isn’t this Application Layer really serving as a new domain model with a built-in Anticorruption Layer (3)? Yes, it is basically a new bargain-basement Bounded Context. Here the Application Services manage a merger of various DTOs, which mimic a sort of Anemic Domain Model (1). It is a bit of a Transaction Script (1) approach that models the Core Domain.

> 说到核心域……这里你是否察觉出了些什么？这里的应用层不是成了一个拥有内建防腐层（3）的新领域模型吗？是的，它是一个新的、廉价的限界上下文。在该上下文中，应用服务对多个 DTO 进行合并，产生的结果有点像贫血领域对象（1）。这种方式也有点像是在通过事务脚本（1）来建模核心域。

If you were to decide that Consumer Hive’s three-model composition is crying for a new Domain Model (1) that is a unified object model in a single Bounded Context, you might name the Modules of the new model as follows:

> 如果你认为 Consumer Hive 是将三个模型组合成一个新的领域模型（1），并将其放在一个新的限界上下文中，那么你可通过以下方式来命名新模型中的模块：

```java
com.consumerhive.productreviews.domain.model.product

com.consumerhive.productreviews.domain.model.discussion

com.consumerhive.productreviews.domain.model.review
```

In the end you will have to decide how to model this situation. Will you decide to use strategic design and even tactical design to create a new model? At a minimum, this situation begs the question: Where do we draw the line between composing multiple Bounded Contexts into a single user interface, and creating a new, clean Bounded Context with a unified domain model? Each case must be considered carefully. A less significant system would have other influences and priorities. Still, we must not treat such decisions arbitrarily. Consideration should be given to the criteria provided in Bounded Contexts. In the end the best approach is the one that benefits the business the most.

> 最终，你需要决定如何对这种场景进行建模。你会考虑使用战略设计甚至战术设计来创建一个新模型吗？对于这种场景，我们至少需要回答以下问题：我们是将多个限界上下文组合到单个用户界面中呢，还是创建一些新的、清晰的限界上下文？我们应该仔细地考虑每一种情形，而不是草率地做决定。最终，最好的方式是那些对业务最有益的方式。

## 14.4 INFRASTRUCTURE 基础设施

The job of the infrastructure is to provide technical capabilities for other parts of your application. While avoiding a discussion about Layers (4), it is still useful to maintain a Dependency Inversion Principle mentality. So wherever your infrastructure lives architecturally, it works out very well if its components depend on the interfaces from the user interface, Application Services, and domain model that require special technical capabilities. That way, when an Application Service looks up a Repository, it will be dependent only on the interface from the domain model, but using the implementation from the infrastructure. Figure 14.4 provides the UML static structure diagram to illustrate how that works.

> 基础设施的职责是为应用程序的其他部分提供技术支持。这里，虽然我们避免对分层（4）的讨论，但是保持着依赖倒置原则的心态依然是有用的。因此，从架构上讲，无论基础设施位于什么地方，只要它的组件依赖于用户界面、应用服务和领域模型中的接口，而这些接口又需要特殊的技术支持，那么它都能工作得很好。这样，在应用服务获取资源库时，它只会依赖于领域模型中的接口，而实际使用的则是基础设施中的实现类。在图 14.4 中，静态的 UML 结构图向我们展示了这个过程。

Image

Figure 14.4. The Application Service depends on the Repository interface from the domain model but uses the implementation class from infrastructure. The packages encapsulate broad responsibilities.

The lookup may be implicit through Dependency Injection [Fowler, DI] or using a Service Factory. The final section of this chapter, “Enterprise Component Containers,” discusses these options. Repeating a portion of the Application Service used as a running example, you can see again here how the Service Factory is used to look up the Repository:

> 对资源库的查找可以通过依赖注入[Fowler，DI]或者服务工厂（Service Factory）隐式地完成。本章的最后一节“企业组件容器”讨论了这两种方式。这里，我再次给出前文中关于应用服务的一个例子，从中我们可以看到如何使用服务工厂来获取资源库：

```java
package com.saasovation.identityaccess.application;

public class TenantIdentityService {
    ...
    @Override
    @Transactional(readOnly=true)
    public Tenant tenant(TenantId aTenantId) {
        Tenant tenant =
            DomainRegistry
                .tenantRepository()
                .tenantOfId(aTenantId);
        return tenant;
    }
    ...
}
```

This Application Service could have instead injected the Repository, or we could have set up the inbound dependencies by way of constructor parameters.

> 对于以上的应用服务来说，我们还可以将资源库注入到服务类中，或者通过构造函数的方式将资源库传入。

Implementations of Repositories are kept in the infrastructure because they deal with storage, which is not a responsibility that the model should take on. You would use the infrastructure to implement interfaces that require use of messaging, such as message queues and e-mail. If there are special user interface components that feature generated graphical charts, maps, and the like, these would also be implemented in the infrastructure.

> 资源库的实现被放在了基础设施层中，因为它们负责处理数据存储，而这些不属于模型的职责。你可以使基础设施层实现那些与消息相关的接口，比如消息队列和 E-mail 等。如果还有一些特殊的用户界面组件来处理诸如图表之类的展现，那么它们也应该放在基础设施层中。

## 14.5 ENTERPRISE COMPONENT CONTAINERS 企业组件容器

These days, enterprise application servers are a commodity. There seems to be little innovation in the servers themselves and in the component containers that run inside them. We can use Enterprise JavaBeans (EJB) as Session Facades [Crupi et al.] or simple JavaBeans hosted by inversion-of-control containers, such as Spring, to facilitate the use of Application Services. There are arguments about which is better, but there has also been a lot of convergence among the frameworks. In fact, a peek inside some JEE servers reveals that some are implemented using Spring.

当下，企业应用服务器已经成为了商品。对于这样的服务器及其所包含的组件容器来说，似乎并没有多少创新。对于应用服务来说，我们可以使用 EJB 作为会话门面（Session Facades）[Crupi et al]，或者也可以使用 IOC（Inversion OfControl）容器中的简单 JavaBean，比如使用 Spring。对于孰优孰劣，一直存在着争论，但是这些框架却存在着一种合流之势。事实上，有些 Java EE 容器在内部即使用了 Spring。

Is It WebLogic or Spring? 是 WebLogic 还是 Spring？

If you were to view a stack trace from the Oracle WebLogic Server, you’d likely see references to classes from Spring Framework. They aren’t part of your application’s deployment. In this case you are using only standard JEE with EJB Session Beans. The Spring classes you are seeing are part of WebLogic’s EJB container implementation. Is this a case of “if you can’t beat them, join them”?

> 如果你深入到 Oracle 的 WebLogic 服务器内部，你将发现它引用了 Spring 框架中的一些类。它们并不是你的应用部署的一部分。此时，你使用的依然是标准 EJB 的 Session Bean。而你所看到的 Spring 类只是 WebLogic 的 EJB 容器实现的一部分。这是不是就是“如果你无法击败它们，就参与到它们中呢”？

I have chosen to implement the three sample Bounded Contexts I have provided using Spring Framework. Yet, these examples would easily carry over to other enterprise container platforms. So there’s nothing lost if you don’t use Spring on your projects, and you should still feel quite comfortable reading through the examples. There are minimal logical differences among the various containers.

> 对于本书的三个限界上下文，我选用了 Spring 框架，但是这些例子同样可以放在其他的企业组件容器中。因此，如果使用的不是 Spring，你也没有失去什么。在阅读这些例子时，你依然不会有什么不适之感，因为这些容器在逻辑上的区别非常小。

In Repositories (12) is seen the Spring configuration used to wire up transactional support for Application Services that is used for persisting domain objects. Here let’s look at other parts of the Spring configuration. Two files of interest are

> 在资源库（12）中，我们看到了为应用服务配置事务的例子。这里，让我们看看 Spring 配置的其他部分，主要有两个 Spring 配置文件：

```
config/spring/applicationContext-application.xml

config/spring/applicationContext-domain.xml
```

As the filenames indicate, Application Services and domain model components are wired in these. Consider a few from the application wiring:

> 应用服务和领域模型组件是通过 AutoWired 的方式联系在一起的。比如：

```xml
<beans ...>
    <aop:aspectj-autoproxy/>
    <tx:annotation-driven transaction-manager="transactionManager"/>
    ...
    <bean
        id="applicationServiceRegistry"
        class="com.saasovation.identityaccess.application.ApplicationServiceRegistry"
        autowire="byName">
    </bean>
    ...
    <bean
        id="tenantIdentityService"
        class="com.saasovation.identityaccess.application.TenantIdentityService"
        autowire="byName">
    </bean>
    ...
</beans>
```

The bean tenantIdentityService is the one reviewed earlier. This bean can be wired into other Spring beans, such as in the user interface. If you prefer a Service Factory rather than injecting bean instances into others, we can use the other bean in the configuration, applicationServiceRegistry. This bean provides lookup access to all Application Services. You’d use it like this:

> 这里的 tenantIdentityService 即我们先前讨论过的应用服务。这个 bean 可以被装配到其他的 bean 中，比如用户界面。如果你更倾向于使用服务工厂，而不是将一个 bean 注入到另一个 bean 中，你也可以使用 applicationServiceRegistry，该 bean 用于查找所有的应用服务。你可以通过如下方式使用：

```java
...
ApplicationServiceRegistry
    .tenantIdentityService()
    .deactivateTenant(tenantId);
```

We can do so because it is itself injected with the Spring Application-Context when the bean is newly created.

> 我们是可以这么做的，因为在该 bean 新建时，它将被自动地注入到 Spring 的 ApplicationContext 中。

The same kind of registry bean is provided for access to components of the domain model, such as Repositories and Domain Services. Here is the Registry, Repository, and Domain Service bean configuration for the domain model:

> 对于领域模型中的组件来说，比如资源库和领域服务等，我们也可以使用相同的方式。此时，注册工厂、资源库和领域服务的配置如下：

```xml
<beans ...>
    ...
    <bean
        id="authenticationService"
        class="com.saasovation.identityaccess.infrastructure.services.DefaultEncryptionAuthenticationService"
        autowire="byName">
    </bean>

    <bean
        id="domainRegistry"
        class="com.saasovation.identityaccess.domain.model.DomainRegistry"
        autowire="byName">
    </bean>

    <bean
        id="encryptionService"
        class="com.saasovation.identityaccess.infrastructure.services.MessageDigestEncryptionService"
        autowire="byName">
    </bean>

    <bean
        id="groupRepository"
        class="com.saasovation.identityaccess.infrastructure.persistence.HibernateGroupRepository"
        autowire="byName">
    </bean>

    <bean
        id="roleRepository"
        class="com.saasovation.identityaccess.infrastructure.persistence.HibernateRoleRepository"
        autowire="byName">
    </bean>

    <bean
        id="tenantProvisioningService"
        class="com.saasovation.identityaccess.domain.model.identity.TenantProvisioningService"
        autowire="byName">
    </bean>

    <bean
        id="tenantRepository"
        class="com.saasovation.identityaccess.infrastructure.persistence.HibernateTenantRepository"
        autowire="byName">
    </bean>

    <bean
        id="userRepository"
        class="com.saasovation.identityaccess.infrastructure.persistence.HibernateUserRepository"
        autowire="byName">
    </bean>
</beans>
```

Using the DomainRegistry, we can access any of these Spring registered beans. All of the beans are also available for dependency injection into other Spring beans. Thus, the Application Services could choose to use the Service Factory or Dependency Injection. See Services (7) for a more in-depth discussion of using these two approaches versus a constructor-based dependency setup.

> 我们可以通过 DomainRegistry 来访问任何一个 Spring 的 bean。同时，这些 bean 也可以依赖注入到其他 bean 中。因此，应用服务可以使用服务工厂和依赖注入的任一种方式。有关这两种方式与基于构造函数的依赖设置的区别，请参考领域服务（7）。

Image

## 14.6 WRAP-UP 本章小结

In this chapter we’ve looked into how the application works outside the domain model.

> 在本章中，我们讨论了应用程序在领域模型之外是如何工作的。

- You’ve considered several techniques for rendering the model’s data into user interfaces.
- You saw ways of accepting user input that is applied to the domain model.
- You’ve learned a variety of options for transferring model data, even when there are possibly many different kinds of user interface types.
- You have looked into Application Services and what they are responsible for.
- You were introduced to an option for decoupling output from specific client types.
- You’ve learned ways to use the infrastructure to keep technical implementations out of the domain model.
- You considered how, using DIP, to make clients of every aspect of the application depend on abstractions rather than implementation details, which promotes loose coupling.
- Finally, you saw how commodity application servers and enterprise component containers can give legs to your applications.

---

> - 你学到了将模型数据渲染到用户界面的多种方法。
> - 对于那些将应用于领域模型的用户输入，你学到了不同的接收方式。
> - 你学到了传输模型数据的不同方式，甚至是当存在多种用户界面类型时的传输方式。
> - 你学习了应用服务以及它们的职责。
> - 你学到了将输出与特定客户类型解耦的一种方式。
> - 你学到了如何使用基础设施将技术实现隔离于领域模型。
> - 你学到了如何使用依赖倒置原则使所有的组件都只依赖于抽象，而不是实现细节。这种方式有助于组件之间的松耦合性。
> - 最后，你学到了如何在自己的应用程序中使用那些商用的应用服务器和企业组件容器。

You should now be on solid footing to implement DDD from the carefully crafted domain model through to the components of the entire application.

> 现在，你已经为实现 DDD 打下了坚实的基础，包括从领域模型到整个应用程序中的所有组件。
