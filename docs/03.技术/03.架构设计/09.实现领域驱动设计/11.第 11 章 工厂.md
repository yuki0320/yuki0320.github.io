---
title: 第 11 章 工厂
date: 2021-01-07 16:25:13
permalink: /pages/16c839/
categories:
  - 技术
  - 技术文档
  - 实现领域驱动设计
tags:
  - 
---
# 第 11 章 工厂

I can’t abide ugliness in factories! In we go, then! But do be careful, my dear children! Don’t lose your heads! Don’t get overexcited! Keep very calm!

> 我忍受不了这个脏兮兮的工厂了，我们还是走吧！但是要多加小心，我的孩子！不要迷失了自我，也不要过度兴奋！保持冷静！

——Willy Wonka

Of all the patterns used in DDD, Factory is probably one of the better known. Highly publicized in Design Patterns [Gamma et al.] are Abstract Factory, Factory Method, and Builder. I won’t in any way attempt to overshadow the advice given there, or that provided by [Evans]. The focus here is to provide examples of how you can use Factories in the domain model.

> 在 DDD 中众多模式中，工厂（Factory）可能是最为大家所知的模式了。在设计模式[Gamma et al.]中，存在抽象工厂（Abstract Factory）、工厂方法（FactoryMethod）和创建者（Builder）等模式。这里，我并不是在掩盖[Gamma et al.]和[Evans]的光环。在本章中，我们所关注的是如何在领域模型中使用工厂。

Road Map to This Chapter 本章学习路线图

- Learn why the use of Factories can produce expressive models that adhere to the Ubiquitous Language (1).
- See how SaaSOvation uses Factory Methods as Aggregate (10) behaviors.
- Consider how to use Factory Methods to create Aggregate instances of other types.
- Learn how Domain Services can be designed as Factories while interacting with other Bounded Contexts (2) and translating foreign objects to local types.

---

> - 学习为什么工厂可以创建具有表达性的、符合通用语言（1）的模型。
> - 学习 SaaSOvation 团队是如何将工厂方法作为聚合（10）的行为方法的。
> - 学习如何使用工厂方法来创建其他类型的聚合。
> - 学习在与其他限界上下文（2）集成并将外部对象翻译成本地对象时，如何将领域服务当作工厂来使用。

## 11.1 FACTORIES IN THE DOMAIN MODEL 领域模型中的工厂

Consider the primary motivations for using Factories:

> 考虑使用工厂的主要动机：

Shift the responsibility for creating instances of complex objects and AGGREGATES to a separate object, which may itself have no responsibility in the domain model but is still part of the domain design. Provide an interface that encapsulates all complex assembly and does not require the client to reference the concrete classes of the objects being instantiated. Create entire AGGREGATES as a piece, enforcing their invariants. [Evans, p. 138]

> 将创建复杂对象和聚合的职责分配给一个单独的对象，该对象本身并不承担领域模型中的职责，但是依然是领域设计的一部分。工厂应该提供一个创建对象的接口，该接口封装了所有创建对象的复杂操作过程，同时，它并不需要客户去引用那个实际被创建的对象。对于聚合来说，我们应该一次性地创建整个聚合，并且确保它的不变条件得到满足。[Evans，p.138]

A Factory may or may not have additional responsibilities in the domain model other than object creation. An object that has the purpose only of instantiating a specific Aggregate type will have no other responsibilities and will not even be considered a first-class citizen of the model. It is only a Factory. An Aggregate Root that provides a Factory Method for producing instances of another Aggregate type (or inner parts) will have the primary responsibility of providing its main Aggregate behavior, the Factory Method being just one of those.

> 除了创建对象之外，工厂并不需要承担领域模型中的其他职责。一个只用于创建某种聚合的对象并不会拥有其他的职责，甚至不会被看作是模型中的一等公民。它只是一个工厂而已。一个含有工厂方法的聚合根的主要职责是完成它的聚合行为，而工厂方法只是其中之一。

The latter is what tends to occur more frequently in my examples. The Aggregates I demonstrate have mostly non-complex construction. Yet, some important details of Aggregate construction must be protected against the production of wrong state. Consider the demands of a multitenancy environment. If an Aggregate instance were created under the wrong tenant, giving it the wrong TenantId, it could be disastrous. There is a high degree of accountability to keep all data of each tenant segregated and secure from all others. Placing a carefully designed Factory Method on specific Aggregate Roots can ensure that tenancy and other association identities are created correctly. It simplifies clients, requiring them to pass only basic parameters, often Value Objects (6) only, by hiding the construction details from them.

> 在本书的例子中，我们将更多地使用后一种方式。本书示例中大部分聚合的创建过程都并不复杂。但是，我们必须考虑到创建过程中的一些重要细节，否则，所创建的聚合将处于不正确状态。考虑一下，在多租户环境中，如果一个聚合被创建在了一个错误的租户之下（即该聚合持有了错误的 TenantId），那么结果将是灾难性的。我们需要将每个租户所持有的数据与其他租户分离开来。在聚合根中使用适当的工厂方法可以保证这一点，同时也方便了客户端，因为此时客户端只需要传入基本的参数——通常只是些值对象（6），这样我们也达到了向客户端隐藏创建细节的目的。

Further, Factory Methods on Aggregates allow you to express the Ubiquitous Language in ways not possible through constructors alone. When the behavioral method name is expressive with respect to the Ubiquitous Language, you’ve made an additional powerful case for using a Factory Method.

> 另外，在聚合上使用工厂方法也有助于更好地表达通用语言，而这是使用构造函数所不能达到的。

Cowboy Logic 牛仔的逻辑

LB: “I used to work in a fire hydrant factory. You couldn’t park anywhere near the place.”

> LB：“我曾经在一个消防栓工厂工作。在工厂附近，你几乎找不到停车的地方。”

Image

The sample Bounded Contexts do in some cases require complex construction. These situations occur when Integrating Bounded Contexts (13). At those times Services (7) function as Factories producing Aggregates or Value Objects of various types.

> 在本书的示例限界上下文中，的确存在需要复杂创建过程的情况，比如在集成限界上下文（13）中就出现了。在那种情况下，领域服务（7）扮演了工厂的角色，它用于创建不同类型的聚合和值对象。

One case where you would find an Abstract Factory of great benefit is when creating objects of different types in a class hierarchy, which is a classic use. The client is required to pass in only some basic parameters from which the Factory can determine the concrete type that must be created. I don’t have any domain-specific class hierarchies among my examples, so I won’t be demonstrating this usage here. If you see class hierarchies in your future domain modeling efforts, I suggest that you look at the related discussion under Repositories (12). It will help you enter such an effort with eyes wide open. If you decide to use class hierarchies in your design, be prepared for the potential for pain that could result.

> 在一个类层级中，如果我们需要创建不同类型的对象，那么我们可以使用抽象工厂，这也是该模式的典型应用场景。此时，客户端只需要传入一些基本的参数，抽象工厂将通过这些参数来确定需要创建的实际类型。在本书的例子中，并不存在特定于领域的类层级，因此本章不会讲到对抽象工厂的使用。如果你有这样的需求，可以参考一下资源库（12）中相关的讨论。如果你决定在自己的设计中采用类层级，那么请准备好承担它有可能导致的后果。

## 11.2 FACTORY METHOD ON AGGREGATE ROOT 聚合根中的工厂方法

Throughout the three sample Bounded Contexts there are Factory sites on Aggregate Root Entities, of which Table 11.1 provides a summary.

> 在本书的 3 个示例限界上下文中，聚合根实体中都存在工厂方法，请参考表 11.1。

Table 11.1. Sites of Factory Methods on Aggregates

Image

I discuss the Product Factory Methods under Aggregates (10). For example, its method planBacklogItem() creates a new BacklogItem, which is an Aggregate that is subsequently returned to the client.

> 在聚合（10）中，我们讨论到了 Product 上的工厂方法。比如，planBacklogItem（）方法用于创建新的 BacklogItem，BacklogItem 本身也是一个聚合，它将返回给客户端。

To demonstrate the design of Factory Methods, let’s look at the three in the Collaboration Context.

> 为了展示对工厂方法的设计，让我们看看协作上下文中的 3 个工厂方法。

### 11.2.1 Creating CalendarEntry Instances 创建 CalendarEntry 实例

Let’s look at the design. The Factory we are considering now has its site on Calendar and is used to create CalendarEntry instances. The CollabOvation team takes us through the implementation.

> 让我们先来看看对工厂的设计。在 Calendar 中，一个工厂方法用于创建 CalendarEntry 实例。CollabOvation 团队向我们展示了该实现过程。

Image

Here’s a test developed to demonstrate how the Calendar Factory Method should be used:

> 下面的测试向我们展示了对 Calendar 中工厂方法的使用：

```java
public class CalendarTest extends DomainTest {
    private CalendarEntry calendarEntry;
    private CalendarEntryId calendarEntryId;
    ...
    public void testCreateCalendarEntry() throws Exception {
        Calendar calendar = this.calendarFixture();
        DomainRegistry.calendarRepository().add(calendar);
        DomainEventPublisher
            .instance()
            .subscribe(
                new DomainEventSubscriber<CalendarEntryScheduled>() {
                public void handleEvent(
                        CalendarEntryScheduled aDomainEvent) {
                    calendarEntryId = aDomainEvent.calendarEntryId();
                }
                public Class<CalendarEntryScheduled>
                        subscribedToEventType() {
                    return CalendarEntryScheduled.class;
                }
            });
        calendarEntry =
            calendar.scheduleCalendarEntry(
                    DomainRegistry
                        .calendarEntryRepository()
                        .nextIdentity()
                    new Owner(
                        "jdoe",
                        "John Doe",
                        "jdoe@lastnamedoe.org"),
                    "Sprint Planning",
                    "Plan sprint for first half of April 2012.",
                    this.tomorrowOneHourTimeSpanFixture(),
                    this.oneHourBeforeAlarmFixture(),
                    this.weeklyRepetitionFixture(),
                    "Team Room",
                    new TreeSet<Invitee>(0));
        DomainRegistry.calendarEntryRepository().add(calendarEntry);
        assertNotNull(calendarEntryId);
        assertNotNull(calendarEntry);
        ...
    }
}
```

Nine parameters are passed in to scheduleCalendarEntry(). Yet, as seen later, the CalendarEntry constructor requires a total of 11 parameters. We’ll consider the benefits of this in a moment. After a new CalendarEntry is successfully created, the client must add it to its Repository. Failing to do so will release the new instance to be swept by the garbage collector.

> 在上例中，scheduleCalendarEntry（）方法需要 9 个参数。之后你还会发现，CalendarEntry 的构造函数需要 11 个参数。我们将在下文中讨论这种方式的好处。在创建好一个新的 CalendarEntry 之后，客户端需要将其添加到资源库中，否则，该 CalendarEntry 将被垃圾收集器所回收。

The first assertion demonstrates that the CalendarEntryId published with the Event must be non-null, confirming that the Event was successfully published. It’s not that the direct client of Calendar will actually subscribe to that Event, but the test demonstrates that the Event CalendarEntryScheduled is in fact published.

> 测试中的第一个断言语句验证所发布事件中的 CalendarEntryId 不能为 null，这样可以表示事件的成功发送。在本例中，我们并不关心是否有客户端订阅了该事件，而是在于测试 CalendarEntryScheduled 事件的确发布出去了。

The new CalendarEntry instance must also be non-null. We could make additional assertions, but the two just shown are most important to documenting the Factory Method design and the client’s use of it.

> 新创建的 CalendarEntry 实例也不能为 null。当然，我们还可以加入更多的断言，但是对于工厂方法的设计和客户的使用来说，本例中的 2 个断言已经足够了。

Now let’s take a look at the implementation of the Factory Method:

> 接下来，让我们看看工厂方法的实现：

```java
package com.saasovation.collaboration.domain.model.calendar;

public class Calendar extends Entity  {
    ...
    public CalendarEntry scheduleCalendarEntry(
            CalendarEntryId aCalendarEntryId,
            Owner anOwner,
            String aSubject,
            String aDescription,
            TimeSpan aTimeSpan,
            Alarm anAlarm,
            Repetition aRepetition,
            String aLocation,
            Set<Invitee> anInvitees) {
        CalendarEntry calendarEntry =
            new CalendarEntry(
                    this.tenant(),
                    this.calendarId(),
                    aCalendarEntryId,
                    anOwner,
                    aSubject,
                    aDescription,
                    aTimeSpan,
                    anAlarm,
                    aRepetition,
                    aLocation,
                    anInvitees);

        DomainEventPublisher
            .instance()
            .publish(new CalendarEntryScheduled(...));
        return calendarEntry;
    }
    ...
}
```

The Calendar instantiates a new Aggregate, namely, CalendarEntry. The new instance is returned to the client following the Event CalendarEntryScheduled being published. (The details of the Event published are not significant to this discussion.) You may note the lack of guards at the top of this method. It is unnecessary to guard the Factory Method itself since the constructors of each of the Value parameters and the CalendarEntry constructor, as well as the setter methods that the constructor self-delegates to, provide all the needed guards. (See Entities (5) for more details on self-delegation and guards.) If you’d like to be doubly cautious, you could add guards here as well.

> Calendar 创建了一个新的聚合实例，即 CalendarEntry。在 CalendarEntryScheduled 事件发布之后，该实例将被返回给客户端（事件发布细节对本例来说并不重要）。你会发现，在该工厂方法中，我们并没有提供守卫措施。对于工厂方法来说，这也是没有必要的，因为所有值对象的构造函数、CalendarEntry 的构造函数，还有这些构造函数自委派的 setter 方法已经提供了这样的守卫措施（更多有关自委派和守卫的知识，请参考实体（5））。当然，如果你想提供双重守卫，也是可以的。

Image

The team designed the method name to adhere to the Ubiquitous Language. Domain experts, along with the rest of the team, discussed the following scenario:

> 团队成员采用了能够表达通用语言的工厂方法名。这样，领域专家和团队成员都可以使用相同的语言进行交流：

Calendars schedule calendar entries.

日历计划日历条目。

If our design were to support only a public constructor on CalendarEntry, it would reduce the expressiveness of the model and we would not be able to explicitly model that part of the Language of the domain. Using this design requires the full Aggregate constructor to be hidden from clients. We declare the constructor with protected scope, which forces clients to make use of the scheduleCalendarEntry() Factory Method on Calendar:

> 如果我们只是采用了 CalendarEntry 的构造函数，那么这将减弱模型的表达性，同时我们也无法对领域中的那部分通用语言进行建模。在使用工厂方法时，聚合的构造函数对客户端来说是隐藏的。我们将构造函数声明为了 protected，这迫使客户端只能通过 Calendar 的 scheduleCalendarEntry（）工厂方法来创建 CalendarEntry：

```java
public class CalendarEntry extends Entity  {
    ...
    protected CalendarEntry(
        Tenant aTenant, CalendarId aCalendarId,
        CalendarEntryId aCalendarEntryId, Owner anOwner,
        String aSubject, String aDescription, TimeSpan aTimeSpan,
        Alarm anAlarm, Repetition aRepetition, String aLocation,
        Set<Invitee> anInvitees) {
        ...
    }
    ...
}
```

While having the upside of careful construction, the lowered usage burden on clients, and an expressive model, using the Calendar Factory Method does have the downside of a bit more performance overhead. As is the case with any such Aggregate Factory Method, the Calendar will have to be acquired from its persistence store before it can be used to create the CalendarEntry. This extra hit may be well worth it, but as the traffic in this Bounded Context increases, the team will have to weigh the consequences carefully.

> 虽然工厂方法存在诸多优势，但是它却有可能带来性能上的影响。在创建 CalendarEntry 之前，我们必须先从持久化存储中获取到 Calendar 实例。对于其他聚合来说，也存在相同的问题。当然，与工厂方法的优势比起来，这样的性能损耗很可能是值得的。但是，随着该限界上下文吞吐量的增加，团队成员们需要仔细衡量这有可能带来的后果。

Germane to the benefits of using Factories is that two of the CalendarEntry constructor parameters are not passed in by clients. Given that there are 11 required constructor parameters, this design unburdens clients, requiring them to supply only nine. Most of the nine required parameters are fairly easily created by clients. (Admittedly the Set of Invitee instances is more involved, but that’s not the fault of the Factory Method. The team should think in terms of designing a facility to more conveniently provide this Set, which may be pointing toward the creation of a dedicated Factory.)

> 使用工厂方法的另一个好处在于，CalendarEntry 构造函数所需的其中 2 个参数不用客户端传入。该构造函数需要 11 个参数，但是客户端只需要传入 9 个参数，这样便减轻了客户端的负担。此外，这 9 个参数中的多数参数都可以很容易地创建出来（需要承认的是，这里的 Invitee 集合要复杂一些，但是这并不是工厂方法的错。团队成员们应该设计一种能够更方便地创建该集合的方式，这有可能意味着创建一个单独的工厂类）。

Still, the Tenant and associated CalendarId are strictly provided only by the Factory Method. This is where we guarantee that CalendarEntry instances are created only for the correct Tenant and in association with the correct Calendar.

> 另外，创建 CalendarEntry 所需的 Tenant 和 CalendarId 都由工厂方法提供。这样，我们可以保证 CalendarEntry 实例是为正确的 Tenant 所创建的，并且关联了正确的 Calendar。

Let’s now consider one more example from the Collaboration Context.

> 让我们再看看协作上下文中的另一个例子。

### 11.2.2 Creating Discussion Instances 创建 Discussion 实例

Look at the Factory Method on Forum. It has the same motivation and very similar implementation as the one on Calendar, so there is no need to dive into great detail on it. Yet, there is an additional advantage of using the Factory Method here, as the team demonstrates.

> 对于 Forum 中的工厂方法来说，它和 Calendar 中的工厂方法拥有相似的动机和实现，因此，我们没有必要再深入讨论。但是，此处使用工厂方法还有一个额外的好处。

Consider the Language-specific startDiscussion() Factory Method on Forum:

> 考虑以下 Form 中的 startDiscussion（）方法：

```java
package com.saasovation.collaboration.domain.model.forum;

public class Forum extends Entity  {
    ...
    public Discussion startDiscussion(
            DiscussionId aDiscussionId,
            Author anAuthor,
            String aSubject) {
        if (this.isClosed()) {
            throw new IllegalStateException("Forum is closed.");
        }
        Discussion discussion = new Discussion(
                this.tenant(),
                this.forumId(),
                aDiscussionId,
                anAuthor,
                aSubject);
        DomainEventPublisher
            .instance()
            .publish(new DiscussionStarted(...));
        return discussion;
    }
    ...
}
```

Besides creating a Discussion, this Factory Method also guards against creating one if the Forum is closed. The Forum supplies the Tenant and associated ForumId. Thus, only three of five parameters required to instantiate a new Discussion must be supplied by the client.

> 除了创建 Disscussion 之外，如果一个 Forum 处于关闭状态，那么该工厂方法将对这种情况进行保护。Forum 提供了 Tenant 和 ForumId。因此，在 Discussion 构造函数所需的 5 个参数中，客户端只需要传入 3 个参数即可。

This Factory Method also expresses the Ubiquitous Language of the Collaboration Context. The team used Forum’s startDiscussion() to design in just what the domain experts said it should do:

> 该工厂方法同时也表达出了协作上下文中的通用语言。Forum 中的 startDiscussion（）方法很好地表达出了领域专家的意图：

Authors start discussions on forums.

> 作者启动论坛中的讨论。

This allows the client to be just this simple:

> 对于客户端来说，便非常简单了：

```java
Discussion discussion = agilePmForum.startDiscussion(
    this.discussionRepository.nextIdentity(),
    new Author("jdoe", "John Doe", "jdoe@saasovation.com"),
    "Dealing with Aggregate Concurrency Issues");
 assertNotNull(discussion);
...
this.discussionRepository.add(discussion);
```

Simple, indeed, which is always a goal of a domain modeler.

> 的确简单，这也是领域建模者所追求的目标。

This Factory Method pattern can repeat as often as necessary. I think it has been duly demonstrated how effectively Factory Methods on Aggregates can be used to express the Language in Context, reduce the burden on clients when creating new Aggregate instances, and ensure instantiations with correct state.

> 这里的工厂方法模式可以不断地重复使用。总的来说，它拥有以下好处：有效地表达限界上下文中的通用语言；减轻客户端在创建新聚合实例时的负担；确保所创建的实例处于正确的状态。

## 11.3 FACTORY ON SERVICE 领域服务中的工厂

Since much of how I use Services as Factories is related to Integrating Bounded Contexts (13), I leave the bulk of the discussion to that chapter. In that chapter my focus is more on integrating with Anti-Corruption Layer (3), Published Language (3), and Open Host Service (3). Here I want to emphasize the Factory itself and how a Service can be designed as one.

> 对于将领域服务作为工厂来说，由于它和集成限界上下文（13）相关，我将在那章中做详细讨论，其中我的关注点主要集中在对防腐层（3）、发布语言（3）和开放主机服务（3）的集成上。这里，我所强调的是工厂本身以及如何将领域服务设计成工厂。

Image

The team now provides another example from the Collaboration Context. It’s a Factory in the form of CollaboratorService, producing Collaborator instances from tenant and user identity:

> SaaSOvation 团队提供了协作上下文中的另一个例子——CollaborationService，该工厂用于创建 Collaborator 实例：

```java
package com.saasovation.collaboration.domain.model.collaborator;

import com.saasovation.collaboration.domain.model.tenant.Tenant;

public interface CollaboratorService  {
    public Author authorFrom(Tenant aTenant, String anIdentity);

    public Creator creatorFrom(Tenant aTenant, String anIdentity);

    public Moderator moderatorFrom(Tenant aTenant, String anIdentity);

    public Owner ownerFrom(Tenant aTenant, String anIdentity);

    public Participant participantFrom(
            Tenant aTenant,
            String anIdentity);
}
```

This Service provides object translation from the Identity and Access Context to the Collaboration Context. As shown in Bounded Contexts (2), the CollabOvation team doesn’t speak of users when discussing collaboration. It is more to the point that humans in the collaborative media domain are authors, creators, moderators, owners, and participants. To accomplish this, the team will need to interact with the Identity and Access Context behind a Service and transform user and role objects from that model into corresponding collaborator objects of their own model’s Context.

> 该领域服务类将身份与访问上下文中的对象翻译成协作上下文中的对象。在限界上下文（2）中我们讲到，CollabOvation 团队在讨论协作时，他们并不会触及到“用户”这个概念，而是讨论不同的角色，比如作者、创建者、主持者、拥有者和参与者等。为了达到这样的目的，团队需要和身份与访问上下文进行交互，并将其中的用户和角色对象相应地翻译成自己上下文中的协作对象。

Since new objects that are derived from the abstract base Collaborator are created by the Service, it actually functions as a Factory. Taking a look at one of the interface method implementations reveals some of the detail involved:

> 由于继承自抽象基类 Collaborator 的新对象都通过领域服务进行创建，此时的领域服务实际上扮演了工厂的角色。以下是该领域服务的其中一个接口的实现：

```java
package com.saasovation.collaboration.infrastructure.services;

public class UserRoleToCollaboratorService
        implements CollaboratorService {

    public UserRoleToCollaboratorService() {
        super();
    }

    @Override
    public Author authorFrom(Tenant aTenant, String anIdentity) {
        return
            (Author)
                UserInRoleAdapter
                    .newInstance()
                    .toCollaborator(
                            aTenant,
                            anIdentity,
                            "Author",
                            Author.class);
    }
    ...
}
```

Because it is a technical implementation, the class is housed in a Module (9) in the Infrastructure Layer.

> 由于这是一个技术上的实现，该类将被放置于基础设施层的模块（9）中。

The implementation hitches to the UserInRoleAdapter to morph a Tenant and an identity—the user’s username—into an instance of class Author. This Adapter [Gamma et al.] interacts with the Open Host Service of the Identity and Access Context to confirm that the given user is in the role named Author. If that is true, the Adapter delegates to class CollaboratorTranslator to translate the Published Language integration response to an instance of class Author in the local model. The Author, as well as the other Collaborator subclasses, is a simple Value Object:

> 在以上实现中，UserInRoleAdapter 把 Tenant 和一个标识——用户的名字——转换成了一个 Author 实例。该适配器类[Gamma et al.]将和身份与访问上下文的开放主机服务进行交互，以确认一个给定的用户是否拥有 Author 角色。如果是，该适配器将委派给 CollaboratorTranslator 类，该类把发布语言的返回结果翻译成本地模型中的 Author 类。这里的 Author 和其他 Collaborator 子类都是简单的值对象：

```java
package com.saasovation.collaboration.domain.model.collaborator;

public class Author extends Collaborator  {
    ...
}
```

Other than constructors, equals(), hashCode(), and toString(), each of the subclasses receives all state and behavior from Collaborator:

> 和构造函数、equals（）、hashCode（）和 toString（）方法不同的是，每一个子类都从父类 Collaborator 中获得了所有的状态和行为：

```java
package com.saasovation.collaboration.domain.model.collaborator;

public abstract class Collaborator implements Serializable  {
    private String emailAddress;
    private String identity;
    private String name;

    public Collaborator(
            String anIdentity,
            String aName,
            String anEmailAddress) {
        super();
        this.setEmailAddress(anEmailAddress);
        this.setIdentity(anIdentity);
        this.setName(aName);
    }
    ...
}
```

The Collaboration Context uses the username as the Collaborator identity attribute. The emailAddress and name are simple String instances. In this model the team has chosen to keep each of these concepts as simple as possible. The user’s name, for example, is kept as the full name in text. We’ve managed to separate the life cycles and conceptual terminologies from the two Bounded Contexts by means of a Service-Based Factory.

> 在协作上下文中，用户名作为 Collaborator 的标识，即 identity 属性。另外，emailAddress 和 name 都是简单的 String 类型实例。在该模型中，团队决定尽可能地保持这些概念的简单性。比如，对于用户名来说，他们决定使用单个 String 来表示用户的全名。通过使用基于领域服务的工厂，我们得以将两个限界上下文的生命周期和概念术语进行分离。

There is a measure of complexity in UserInRoleAdapter and CollaboratorTranslator. In a nutshell the UserInRoleAdapter is responsible only for communicating with the foreign Context. The CollaboratorTranslator is responsible only for translation that results in creation. See Integrating Bounded Contexts (13) for details.

> 在 UserInRoleAdapter 和 CollaboratorTranslator 中是存在一定复杂度的。简言之，UserInRoleAdapter 只负责与外部上下文的通信，而 CollaboratorTranslator 则只负责翻译和创建新实例。更多细节，请参考集成限界上下文（13）。

Image

## 11.4 WRAP-UP 本章小结

We examined the reasons for using Factories in DDD and how they often fit into the model.

> 在本章中，我们学到了在 DDD 中使用工厂的原因，以及如何将工厂加入到模型中。

- You now understand why the use of Factories can produce expressive models that more closely adhere to the Ubiquitous Language in context.
- You’ve seen two different Factory Methods implemented as Aggregate behaviors.
- This helped you learn how to use Factory Methods to create Aggregate instances of other types, all while ensuring the correct production and use of sensitive data.
- You also learned how Domain Services can be designed as Factories, even interacting with other Bounded Contexts and translating foreign objects to local types.

---

> - 你知道了为什么工厂有利于创建具有表达性的模型——即表达限界上下文中的通用语言。
> - 你学习了如何将聚合的行为方法设计成工厂方法。
> - 你学到了如何使用工厂方法来创建不同类型的聚合实例，并且保证聚合状态的正确性。
> - 你学到了如何将领域服务设计成工厂，甚至包括与其他限界上下文的交互，以及将外部对象翻译成本地对象。

Next, we’ll take a look at how Repositories can be designed for two primary styles of persistence, along with other implementation choices that must be considered.

> 接下来，我们将学习如何通过两种主要的持久化风格来设计资源库，同时还包括如何实现资源库。
