---
title: 第 7 章 领域服务
date: 2021-01-07 16:25:13
permalink: /pages/ae448f/
categories:
  - 技术
  - 技术文档
  - 实现领域驱动设计
tags:
  - 
---
# 第 7 章 领域服务

Sometimes, it just isn’t a thing.

> 有时，它不见得是件东西。

——Eric Evans

A Service in the domain is a stateless operation that fulfills a domain-specific task. Often the best indication that you should create a Service in the domain model is when the operation you need to perform feels out of place as a method on an Aggregate (10) or a Value Object (6). To alleviate that uncomfortable feeling, our natural tendency might be to create a static method on the class of an Aggregate Root. However, when using DDD, that tactic is a code smell that likely indicates you need a Service instead.

> 领域中的服务表示一个无状态的操作，它用于实现特定于某个领域的任务。当某个操作不适合放在聚合（10）和值对象（6）上时，最好的方式便是使用领域服务了。有时我们倾向于使用聚合根上的静态方法来实现这些这些操作，但是在 DDD 中，这是一种坏味道。

Road Map to This Chapter

> 本章路线图

- See how domain model refinements can lead to the realization that you need a Service.
- Learn what a Service in the domain is, and what it isn’t.
- Consider a necessary caution when deciding whether or not to create a Service.
- Discover how to model Services in a domain through two examples from SaaSOvation’s projects.

---

> - 学习如何在领域模型中使用领域服务。
> - 学习什么是领域服务。
> - 学习何时应该使用领域服务。
> - 从 SaaSOvation 项目的两个例子中学习如何对领域服务进行建模。

Smelly code? That’s exactly what SaaSOvation’s developers experienced because of refactoring an Aggregate. Let’s consider their tactical correction. Here’s what happened . . .

> 坏味道？这正是 SaaSOvation 的开发者们在重构聚合时所遇到的问题。让我们看看他们是如何应对这些问题的……

Image

Early on in their project the team had modeled the collection of BacklogItem instances as a composed Aggregate part of Product. That modeling situation allowed calculating the total business priority value of all product backlog items to be a simple instance method on class Product:

> 在项目的早些时候，项目成员们在 Product 中维护了一个 BacklogItem 实例的集合。这种建模方式使得他们可以计算一个 Product 的总业务优先级：

```java
public class Product extends ConcurrencySafeEntity {
    ...
    private Set<BacklogItem> backlogItems;
    ...
    public BusinessPriorityTotals businessPriorityTotals() {
        ...
    }
    ...
}
```

At that time the design made perfect sense because method business-PriorityTotals() would just iterate over the composed BacklogItem instances and come up with the queried total business priority. The design properly answered the query with a Value Object, namely, BusinessPriorityTotals.

> 在当时，这种设计方式是非常完美的，businessPriorityTotals（）方法只需要遍历所有的 BacklogItem 实例，然后计算出总的业务优先级。并且，这种方式适当地使用了值对象 BusinessPriorityTotals。

However, it wouldn’t stay that way. As the analysis found in Aggregates (10) showed, the large cluster Product needed to be broken up, and BacklogItem would be redesigned to stand on its own as an Aggregate. Thus, the previous design that used an instance method no longer worked.

> 但是，我却不这么认为。通过对聚合（10）的分析我们知道，这里的 Product 对象过于庞大，而 BacklogItem 本身就应该成为一个聚合。因此，上面的实例方法 businessPriorityTotals（）已经不再适用于这种场景。

Since Product no longer contained the BacklogItem collection, the team’s first reaction was to refactor the existing instance method to use the new BacklogItemRepository to get all the BacklogItem instances the calculation needed. Does that sound right?

> 由于 Product 不再包含 BacklogItem 集合，团队成员们的第一反应便是使用一个资源库 BacklogItemRepository 来获取所需的 BacklogItem 实例，这是一种好的做法吗？

Actually, the senior team mentor persuaded the team not to do that. As a rule of thumb, we should try to avoid the use of Repositories (12) from inside Aggregates, if at all possible. What about just making the same method static on class Product and passing in the collection of BacklogItem instances that static method would need for the calculation? That way the method would remain almost intact, except for the new parameter:

> 事实上，团队中的高级开发者并不建议这么做。一个基本的原则是，我们应该尽量避免在聚合中使用资源库（12）。那么，将 businessPriorityTotals（）方法声明为静态方法，然后将 BacklogItem 集合作为参数传入，如何呢？这样，我们几乎不用对该方法做多少修改，只需要传入新的参数即可：

```java
public class Product extends ConcurrencySafeEntity {
    ...
    public static BusinessPriorityTotals businessPriorityTotals(
            Set<BacklogItem> aBacklogItems) {
        ...
    }
    ...
}
```

Was Product really the best place to create the static method? It seemed difficult to determine where it really belonged. Since the operation actually only used the business priority values of each BacklogItem, maybe the static method belonged there. Still, the business priority being sought was that of a product, not a backlog item. Quandaries.

> 请思考，Product 是创建该静态方法的最佳位置吗？看来要将该方法放在合适的地方并不是一件易事。由于该方法只使用了每个 BacklogItem 中的值对象，将该方法放在 BacklogItem 上似乎更合适。但是，这里计算所得的业务价值却是属于 Product 的，而不是 BacklogItem。进退两难啊！

At that point the mentoring senior developer spoke up. He noted that the team’s entire source of discomfort could be dismissed with a single modeling tool, the Domain Service. How would that work?

> 此时，团队中的高级开发者发话了。他指出，这些问题用一个单一的建模工具就可以解决，即领域服务（Domain Service）。那么，领域服务是如何工作的呢？

Let’s first establish some background. Then we’ll revisit this modeling situation and see what the team decided to do.

> 让我们先了解一些背景知识，再回过头来看看这个建模场景，看看 SaaSOvation 团队做了什么样的决定。

## 7.1 WHAT A DOMAIN SERVICE IS (BUT FIRST, WHAT IT IS NOT) 什么是领域服务（首先，什么不是领域服务）

When we hear the term service in a software context, we might naturally envision a coarse-grained component that enables a remote client to interact with a complex business system. That basically describes a service in a Service-Oriented Architecture (4). There are different technologies and approaches for developing SOA services. In the end these kinds of services emphasize system-level remote procedure calls (RPCs) or message-oriented middleware (MoM), where other systems across the data center, or across the globe, are able to interact with the service to carry out business transactions.

> 当我们在软件开发领域中听到“服务”这个词时，自然地我们可能会想到一个远程客户端与某个复杂的业务系统交互的场景，该场景基本上描述了 SOA（4）中的一个服务。有多种技术和方法可以实现 SOA 服务，最终这些服务强调的都是系统层面的远程过程调用（RPC）或者面向消息的中间件（MoM）。这些技术使得我们可以通过服务与分布在不同地方的系统进行业务交互。

None of those is a Domain Service.

> 以上这些都不是领域服务。

Further, don’t confuse a Domain Service with an Application Service. We don’t want to house business logic in an Application Service, but we do want business logic housed in a Domain Service. If you are confused about the difference, compare with Application (14). Briefly, to differentiate the two, an Application Service, being the natural client of the domain model, would normally be the client of a Domain Service. You’ll see that demonstrated later in the chapter.

> 另外，请不要将领域服务与应用服务混杂在一起了。在应用服务中，我们并不会处理业务逻辑，但是领域服务却恰恰是处理业务逻辑的。如果你还是不明白它们之间的区别，请参考应用程序（14）。简单来讲，应用服务是领域模型很自然的客户方，进而也是领域服务的客户方。在本章后面，我们将对此进行演示。

Just because a Domain Service has the word service in its name does not mean that it is required to be a coarse-grained, remote-capable, heavyweight transactional operation.1

> 虽然领域服务中有“服务”这个词，但它并不意味着需要远程的、重量级的事务操作[1]。

1. There are times when a Domain Service is concerned with remote invocations on a foreign Bounded Context (2). Yet, the focus here is different in that the Domain Service is not itself providing a remote procedure call interface but is rather the client of the RPC.

Cowboy Logic 牛仔的逻辑

LB: “Always take a good look at what you are about to eat. It’s not so important to know what it is, but it’s critical to know what it was.”

> LB：“在你吃东西之前，请仔细看看你吃的是什么。重要的不是看它现在是什么，而是它之前是什么。”

Image

Services that specifically belong to the business domain are a perfect modeling tool to use when your needs intersect with their sweet spot. So, now that we know what a Domain Service isn’t, let’s consider what it is.

> 领域模型中的服务的确是一种非常好的建模工具。现在，我们已经知道领域服务不是什么了，那么，它到底又是什么呢？。

Sometimes, it just isn’t a thing. . . . When a significant process or transformation in the domain is not a natural responsibility of an ENTITY or VALUE OBJECT, add an operation to the model as a standalone interface declared as a SERVICE. Define the interface in terms of the language of the model and make sure the operation name is part of the UBIQUITOUS LANGUAGE. Make the SERVICE stateless. [Evans, pp. 104, 106]

> 有时，它不见得是一件东西……当领域中的某个操作过程或转换过程不是实体或值对象的职责时，此时我们便应该将该操作放在一个单独的接口中，即领域服务。请确保该领域服务和通用语言是一致的；并且保证它是无状态的。[Evans，pp.104，106]

Since the domain model generally deals with finer-grained behaviors that are focused on some specific aspect of the business at hand, a Service in the domain would tend to adhere to similar tenets. Since it may be dealing with multiple domain objects in a single, atomic operation, it would have the latitude to scale up a bit in complexity.

> 通常来说，领域模型主要关注于特定于某个领域的业务，同样，领域服务也具有相似的特点。由于领域服务有可能在单个原子操作中处理多个领域对象，这将增加领域服务的复杂性。

Under what conditions would an operation not belong on an existing Entity (5) or Value Object? It is difficult to give an exhaustive list of reasons, but I’ve listed a few here. You can use a Domain Service to

> 那么，在什么情况下，一个操作不属于实体（5）或者值对象呢？要给出一个全面的原因列表是困难的，这里我罗列了以下几点。你可以使用领域服务来：

- Perform a significant business process
- Transform a domain object from one composition to another
- Calculate a Value requiring input from more than one domain object

---

> - 执行一个显著的业务操作过程。
> - 对领域对象进行转换。
> - 以多个领域对象作为输入进行计算，结果产生一个值对象。

The last one—a calculation—probably falls under the “significant process” category, but I call it out to be clear. It’s a very common one, and that kind of operation can require two, and possibly many, different Aggregates or their composed parts as input. And when it is just plain clumsy to place the method on any one Entity or Value, it works out best to define a Service. Make sure the Service is stateless and has an interface that clearly expresses the Ubiquitous Language (1) in its Bounded Context.

> 需要明确的是，对于最后一点中的计算过程，它应该具有“显著的业务操作过程”的特点。这也是领域服务很常见的应用场景，它可能需要多个聚合作为输入。当一个方法不便放在实体或值对象上时，使用领域服务便是最佳的解决方法。请确保领域服务是无状态的，并且能够明确地表达限界上下文中的通用语言（1）。

## 7.2 MAKE SURE YOU NEED A SERVICE 请确定你是否需要一个领域服务

Don’t lean too heavily toward modeling a domain concept as a Service. Do so only if the circumstances fit. If we aren’t careful, we might start to treat Services as our modeling “silver bullet.” Using Services overzealously will usually result in the negative consequences of creating an Anemic Domain Model [Fowler, Anemic], where all the domain logic resides in Services rather than mostly spread across Entities and Value Objects. The following analysis shows the importance of thinking carefully about the tactics you should employ for each modeling situation. Following this guidance should help you make good decisions about whether or not to model a Service.

> 请不要过于倾向于将一个领域概念建模成领域服务，而是只有在有必要的时候才这么做。一不小心，我们就有可能陷入将领域服务作为“银弹”的陷进。过度地使用领域服务将导致贫血领域模型[Fowler，Anemic]，即所有的业务逻辑都位于领域服务中，而不是实体和值对象中。下面的例子为我们展示了仔细思考的重要性。以这些例子为指导，你将学到应该在什么情况下使用领域服务。

Let’s investigate an example of recognizing the need to model a Service. Think of trying to authenticate a User in our Identity and Access Context. Recall that in Entities (5) we ran into this domain scenario that the team wanted to push off until later. Well, later is now:

> 让我们来看一个需要建立领域服务的例子。考虑身份与访问上下文，我们需要对一个 User 进行认证。回忆一下，在实体（5）章节中，我们曾遇到了一个建模场景，那时团队决定将问题延后。那时所说的“延后”便是现在了：

- Users of a system must be authenticated but can be authenticated only if the tenant is active.

> - 系统必须对 User 进行认证，并且只有当 Tenant 处于激活状态时才能对 User 进行认证。

Let’s consider why a Service is necessary. Could we simply place this behavior on an Entity? From a client’s perspective, maybe we could model authentication like this:

> 我们来看看为什么领域服务在此时是必要的。我们可以简单地将该认证操作放在实体上吗？从客户的角度来看，我们可能会使用以下代码来实现认证过程：

Click here to view code image

```java
// client finds User and asks it to authenticate itself
boolean authentic = false;
User user =
    DomainRegistry
        .userRepository()
        .userWithUsername(aTenantId, aUsername);
if (user != null) {
    authentic = user.isAuthentic(aPassword);
}
return authentic;
```

I think there are at least a few problems with this design. We require clients to understand what it means to authenticate. They have to find the User and then ask the User if a given password matches the one the User holds. Also, the Ubiquitous Language is not explicitly modeled. Here we asked the User if it “is authentic” rather than ask the model to “authenticate.” If possible it would be best to model in terms of the natural expressions spoken by the team, rather than force the team to adjust their view away from what comes naturally because we failed to better model the concept. But there are worse problems than these.

> 对于以上设计，我认为至少存在两个问题。首先，客户端需要知道某些认证细节，他们需要找到一个 User，然后再对该 User 进行密码匹配。这种方法也不能显式地表达通用语言。这里，我们询问的是一个 User“是否被认证了”，而没有表达出“认证”这个过程。在有可能的情况下，我们应该尽量使建模术语直接地表达出团队成员的交流用语。但是，还有更糟糕的。

This does not properly model what that team discovered about authenticating a user. A glaring omission is that there is no check to determine whether or not the tenant is active. Per the requirement, if the tenant under which the user resides is not active, the user is not authenticated. Perhaps we could solve the problem like this:

> 这种建模方式并不能准确地表达出团队成员所指的“对 User 进行认证”的过程。它缺少了“检查 Tenant 是否处于激活状态”这个前提条件。如果一个 User 所属的 Tenant 处于非激活状态，我们便不应该对该 User 进行认证。或许我们可以通过以下方法予以解决：

```java
// maybe this way is better ...
boolean authentic = false;
Tenant tenant =
    DomainRegistry
        .tenantRepository()
        .tenantOfId(aTenantId);
if (tenant != null && tenant.isActive()) {
    User user =
        DomainRegistry
            .userRepository()
            .userWithUsername(aTenantId, aUsername);
    if (user != null) {
        authentic = tenant.authenticate(user, aPassword)
    }
}
return authentic;
```

This test does properly determine that the Tenant is active before carrying on with authentication. We were also able to rid User of method isAuthentic() by placing authenticate() on Tenant.

> 这种方式的确对 Tenant 的活跃性做了检查，同时我们也将 User 的 isAuthentic（）方法换成了 Tenant 的 authenticate（）方法。

But there are problems with this. Look at the additional burden that we’ve heaped on the client. It now needs to understand much more about authentication than it should. We could alleviate this a bit by checking whether Tenant isActive() inside method authenticate(), but I’d argue that that is not an explicit model. It also produces another problem. Now Tenant might need to understand what to do with a password. Recall that another requirement was realized, though not specifically called out in the authentication scenario:

> 然而，这种方式也是有问题的。请看看我们带给客户端的额外负担，此时客户端需要知道更多的认证细节，而这些是他们不应该知道的。当然，我们可以将 Tenant 的 isActive（）方法放在 authenticat（）方法中，但是我得说，这并不是一个显式的模型。同时，这将带来另外一个问题，即此时的 Tenant 需要知道如何对密码进行操作。回忆一下该认证过程的另一个需求：

- Passwords must be stored encrypted, not as clear text.

> - 必须对密码进行加密，并且不能使用明文密码。

With our proposed solutions, we seem to keep producing more friction in the model. With the latest proposal we have to choose one of four undesirable approaches:

> 对于以上解决方案，我们似乎给模型带来了太多的问题。对于最后一种方案，我们必须从以下四种解决办法中选择一种：

1. Handle encryption in Tenant and pass the encrypted password to User. This violates Tenant’s Single Responsibility [Martin, SRP] to deal with modeling only a tenant.
2. User may already need to know a little bit about encryption since it must guarantee that any stored password is encrypted. If so, create a method on User that knows how to authenticate given a clear-text password. But in this case authentication becomes a facade on Tenant that is fully implemented only on User. Further still, User must have a protected authentication interface to prevent clients outside the model from directly using it.
3. Tenant asks User to encrypt the clear-text password, then it compares it with the one User is holding. This seems to have extra steps with an untidy set of collaborations. Tenant is still required to understand the details of authentication even though it doesn’t quite carry it out.
4. Have the client encrypt the password and pass it in to the Tenant. This adds further to the responsibility that the client has, when in fact the client should need to know nothing of the need to encrypt passwords.

---

> 1. 在 Tenant 中处理对密码的加密，然后将加密后的密码传给 User。这种方法违背了单一职责原则[Martin，SRP]。
> 2. 由于一个 User 必须保证对密码的加密，它可能已经知道了一些加密信息。如果是这样，我们可以在 User 上创建一个方法，该方法对明文密码进行认证。但是，在这种方式下，认证过程变成了 Tenant 上的门面（Facade），而实际的认证功能全在 User 上。另外，User 上的认证方法必须声明为 protected，以防止外界客户端对认证方法的直接调用。
> 3. Tenant 依赖于 User 对密码进行加密，然后将加密后的密码与原有密码进行匹配。这种方法似乎在对象协作之间增加了额外的步骤。此时，Tenant 依然需要知道认证细节。
> 4. 让客户端对密码进行加密，然后将其传给 Tenant。这样导致的问题在于，客户端承载了它本不应该有的职责。

None of these proposals help much, and the client is still too complex. Responsibility that we’ve dumped on the client should instead be elegantly tucked away in the model. Knowledge that is purely domain specific should never be leaked out into clients. Even if the client is an Application Service, that component is not responsible for the domain of identity and access management.

> 以上这些方法都无济于事，同时客户端依然非常复杂。强加在客户端上的职责应该在我们自己的模型中予以处理。只与领域相关的信息决不能泄漏到客户端中去。即使客户端是一个应用服务，它也不应该负责对身份与访问权限的管理。

Cowboy Logic 牛仔的逻辑

AJ: “When you find yourself in a hole, the first thing to do is stop digging.”

> AJ：“当你发现自己在一个洞穴中时，第一件要做的事便是停止凿洞。”

Image
Really, the only business responsibility that the client should have is to coordinate the use of a single domain-specific operation that handles all other details of the business problem:

> 回想一下，客户端需要处理的唯一业务职责是：调用单个业务操作，而由该业务操作去处理所有的业务细节：

```java
// inside an Application Service client with
// only task coordination responsibility
UserDescriptor userDescriptor =
    DomainRegistry
        .authenticationService()
        .authenticate(aTenantId, aUsername, aPassword);
```

In this simple and elegant solution, the client need only obtain a reference to a stateless instance of AuthenticationService and then ask it to authenticate(). This pushes all details of authentication out of the Application Service client and into the Domain Service. Any number of domain objects may be used by the Service, as needed. This includes ensuring that password encryption is performed as appropriate. The client doesn’t need to understand any of those details. The Ubiquitous Language in the Context is satisfied because the proper terms are expressed by the software that models the identity management domain, rather than partly by the model and partly by the client.

> 以上方式是简单的，也是优雅的。客户端只需要获取到一个无状态的 AuthenticationService，然后调用它的 authenticate（）方法即可。这种方式将所有的认证细节放在领域服务中，而不是应用服务。在需要的情况下，领域服务可以使用任何领域对象来完成操作，包括对密码的加密过程。客户端不需要知道任何认证细节。此时，通用语言也得到了满足，因为我们将所有的领域术语都放在了身份管理这个领域中，而不是一部分放在领域模型中，另一部分放在客户端中。

A Value Object, UserDescriptor, is returned from the Service method. This object is small and secure. Unlike a full User, it includes only a few attributes essential to referencing a User:

> 领域服务方法返回一个 UserDescirptor 值对象，这是一个很小的对象，并且是安全的。与 User 相比，它只包含 3 个关键属性：

```java
public class UserDescriptor implements Serializable  {
    private String emailAddress;
    private TenantId tenantId;
    private String username;

    public UserDescriptor(
            TenantId aTenantId,
            String aUsername,
            String anEmailAddress) {
        ...
    }
    ...
}
```

It is suitable for storing in a per-user Web session. The client Application Service may itself return this object to its invoker or create one more suitable for it.

> 该 UserDescriptor 对象可以存放在一次 Web 会话（Session）中。对于作为客户端的应用服务来说，它可以进一步将该 UserDescriptor 返回给它自己的调用者。

## 7.3 MODELING A SERVICE IN THE DOMAIN 建模领域服务

Depending on the purpose of a Domain Service, it can be quite simple to model. You’ll have to decide whether or not your Service should have a Separated Interface [Fowler, P of EAA]. If so, this might be the interface definition:

> 根据创建领域服务的目的，有时对领域服务进行建模是非常简单的。你需要决定你所创建的领域服务是否需要一个独立接口[Fowler，P of EAA]。如果是，你的领域服务接口可能与以下接口相似：

```java
package com.saasovation.identityaccess.domain.model.identity;

public interface AuthenticationService {
    public UserDescriptor authenticate(
            TenantId aTenantId,
            String aUsername,
            String aPassword);
}
```

The interface is declared in the same Module (9) as the identity-specific Aggregates, such as Tenant, User, and Group. That is done because AuthenticationService is an identity concept, and we currently place all identity-related concepts in the identity Module. The interface definition itself is quite simple. Only one operation, authenticate(), is necessary.

> 该接口和那些与身份相关的聚合（比如 Tenant，User 和 Group）定义在相同的模块（9）中，因为 AuthenticationService 也是一个与身份相关的概念。当前，我们将所有与身份相关的概念都放在 identity 模块中。该接口定义本身是简单的，只有一个 authenticate（）方法。

A choice we have is where to place the implementation class. If you are using the Dependency Inversion Principle (4) or Hexagonal (4), you may decide to place this somewhat technical implementation class in a location outside the domain model. Technical implementations may be housed in a Module in the Infrastructure Layer, for example.

> 对于该接口的实现类，我们可以选择性地将其存放在不同的地方。如果你正使用依赖倒置原则（4）或六边形（4）架构，那么你可能会将这个多少有些技术性的实现类放置在领域模型之外。比如，技术实现类可以放置在基础设施层的某个模块中。

Here is the class:

> 以下是对该接口的实现：

```java
package com.saasovation.identityaccess.infrastructure.services;

import com.saasovation.identityaccess.domain.model.DomainRegistry;
import com.saasovation.identityaccess.domain.model.identity.AuthenticationService;
import com.saasovation.identityaccess.domain.model.identity.Tenant;
import com.saasovation.identityaccess.domain.model.identity.TenantId;
import com.saasovation.identityaccess.domain.model.identity.User;
import com.saasovation.identityaccess.domain.model.identity.UserDescriptor;

public class DefaultEncryptionAuthenticationService
        implements AuthenticationService  {
    public DefaultEncryptionAuthenticationService() {
        super();
    }

    @Override
    public UserDescriptor authenticate(
            TenantId aTenantId,
            String aUsername,
            String aPassword) {
        if (aTenantId == null) {
            throw new IllegalArgumentException(
                    "TenantId must not be null.");
        }
        if (aUsername == null) {
            throw new IllegalArgumentException(
                    "Username must not be null.");
        }
        if (aPassword == null) {
            throw new IllegalArgumentException(
                    "Password must not be null.");
        }

        UserDescriptor userDescriptor = null;
        Tenant tenant =
            DomainRegistry
                .tenantRepository()
                .tenantOfId(aTenantId);
        if (tenant != null && tenant.isActive()) {
            String encryptedPassword =
                DomainRegistry
                    .encryptionService()
                    .encryptedValue(aPassword);
            User user =
                DomainRegistry
                    .userRepository()
                    .userFromAuthenticCredentials(
                            aTenantId,
                            aUsername,
                            encryptedPassword);
            if (user != null && user.isEnabled()) {
                userDescriptor = user.userDescriptor();
            }
        }
        return userDescriptor;
    }
}
```

The method guards against null parameters. Otherwise, if the authentication process fails under normal conditions, the returned UserDescriptor will be null.

> 该方法首先对 null 参数进行检查。如果在正常情况下认证失败，那么该方法返回的 UserDescriptor 将为 null。

To authenticate we begin by attempting to retrieve the Tenant from its Repository using its identity. If the Tenant both exists and is active, we next encrypt the clear-text password. We do that now because we will use the encrypted password to retrieve the User. Rather than request the User only from a TenantId and matching username, we also match on the encrypted password. (The result of encryption is always the same for two equal clear-text passwords.) The Repository is designed to filter on all three.

> 在对一个 User 进行认证时，我们首先根据 aTenantId 从 Tenant 的资源库中取出对应的 Tenant。如果 Tenant 存在并且处于激活状态，下一步我们将对传入的明文密码进行加密。加密的目的在于，我们需要通过加密后的密码来获取一个 User。在获取一个 User 时，我们不但需要传入 aTenantId 和 username，还需要传入加密后的密码进行匹配（对于两个明文相同的密码，加密后也是相同的）。User 的资源库将根据这三个参数来定位一个 User。

If the human user has submitted the correct tenant identity, username, and clear-text password, it will result in retrieving the matching User instance. Still, this does not completely prove the user’s authenticity. There is one final requirement not yet handled:

> 如果用户提交的 aTenantId、username 和 password 都是正确的，我们将获得相应的 User 实例。但是，此时我们依然不能对该 User 进行认证，我们还需要处理最后一条需求：

- Users can be authenticated only if they are enabled.

> - 只有在一个 User 被激活后，我们才能对该 User 进行认证。

Even if the Repository finds the filtered User instance, it may have been disabled. Providing the possibility of disabling a User allows the tenant to control user authentication at a different level. Thus, as a final step the User instance must be both non-null and enabled, which will result in a UserDescriptor being derived from the User.

> 即便我们通过资源库找到了一个 User，该 User 也有可能处于未激活状态。通过向 User 添加激活功能，Tenant 可以从另一个层面来控制对 User 的认证。因此，认证过程的最后一步即是检查所获取到的 User 实例是否为 null 和是否处于激活状态。

### 7.3.1 Is Separated Interface a Necessity? 独立接口有必要吗

Since this AuthenticationService does not have a technical implementation, is it really necessary to create a Separated Interface and implementation class, and in separate Layers and Modules? No, it is not, in fact, an absolute necessity. We could have created this particular Service with only a single implementation class with the name of the Service:

> 由于这里的 AuthenticationService 并没有一个技术上的实现，我们真的有必要为其创建一个独立接口并将其与实现类分离在不同的层和模块中吗？这是没有必要的。我们只需要创建一个实现类即可，其名字与领域服务的名字相同。

```java
package com.saasovation.identityaccess.domain.model.identity;

public class AuthenticationService {
    public AuthenticationService() {
        super();
    }

    public UserDescriptor authenticate(
            TenantId aTenantId,
            String aUsername,
            String aPassword) {
        ...
    }
}
```

There would be nothing wrong with this. You might even consider this a more fitting approach since this particular Service may never need to have multiple implementations. However, given that different tenants might eventually desire specialized security standards, it’s possible that there could be multiple implementations. At this point in time, however, the team has decided to drop the use of a Separated Interface and go with the class as shown here.

> 对于领域服务来说，以上的例子同样是可行的。我们甚至会认为这样的例子更加合适，因为我们知道不会再有另外的实现类。但是，不同的租户可能有不同的安全认证标准，所以产生不同的认证实现类也是有可能的。然而此时，SaaSOvation 的团队成员决定弃用独立接口，而是采用了上例中的实现方法。

Naming Your Implementation Class 给领域服务的实现类命名

In the Java world it’s become quite common to name the implementation class with its interface’s name as a prefix and Impl as a postfix. In our example using this approach would render the name Authentication-ServiceImpl. Further, the interface and implementing class are often housed in the same package. Is this a good thing?

> 在 Java 世界中，常见的命名实现类的方法便是给接口名加上 Impl 后缀。按照这种方法，我们的认证实现类为 AuthenticatioinServiceImpl。此外，实现类和接口通常被放在相同的包下。这是一种好的做法吗？

Actually, if your implementation class is named this way, it’s probably a very good indication that you don’t need a Separated Interface, or that you need to think more carefully about the name of the implementing class. So, no, the AuthenticationServiceImpl name isn’t a really good one. But then again, DefaultEncryptionAuthenticationService is not particularly useful either. For that reason the SaaSOvation team decided to eliminate the Separated Interface for now and go with AuthenticationService as a simple class instead.

> 事实上，如果你采用这种方式来命名实现类，这往往意味着你根本就不需要一个独立接口。因此，在命名一个实现类时，我们需要仔细地思考。这里的 AuthenticationServiceImpl 并不是一个好的实现类名，而 DefaultEncryptionAuthenticationService 也不见得能好到哪里去。基于这些原因，SaaSOvation 的团队成员决定去除独立接口，而直接使用 AuthenticationService 作为实现类。

If your implementation class has specific decoupling goals because you are providing multiple specific implementations, name the class according to its specialty. The need to name each specialized implementation carefully is proof that specialties exist in your domain.

> 如果领域服务具有多个实现类，那么我们应该根据各种实现类的特点进行命名，而这往往又意味着在你的领域中存在一些特定的行为功能。

Some will conclude that having the interface and implementation class similarly named makes large packages of these pairs easier to browse and navigate. However, others would conclude that such large packages are poorly designed according to the goals of Modules. Further still, those with focused modularity goals will also favor placing the interface and various implementation classes in separate packages, as we do with Dependency Inversion Principle (4). For example, the EncryptionService interface is in the domain model, while MD5EncryptionService resides in infrastructure.

> 有人认为采用相似的名字来命名接口和实现类有助于代码浏览和定位。但是，还有人则认为将接口和实现类放在相同的包中会使包变得很大，这是一种糟糕的模块设计，因此他们偏向于将接口和实现类放在不同的包中，我们在依赖倒置原则（4）中便是这么做的。比如，可以将接口 EncryptionService 放在领域模型中，而将 MD5EncryptionService 放在基础设施层中。

Eliminating the Separated Interface for nontechnical Domain Services will not weaken testability since any interfaces that the Service depends on can be injected or resolved by a test-configured Service Factory, or you could pass in as parameters instances of inbound and outbound dependencies as needed. Remember, too, that nontechnical, domain-specific Services, such as calculations, must be tested for correctness.

> 对于非技术性的领域服务来说，去除独立接口是不会破坏可测试性的，因为这些领域服务所依赖的所有接口都可以注入进来，或者通过服务工厂（Service Factory）进行创建。请记住，非技术性的领域服务，比如计算性的服务等，都必须进行正确性测试。

Understandably this is a controversial topic, and I am aware that there is a large camp that regularly names interface realizations using Impl. Just be aware that there is a well-informed polar opposite to that camp that has very sound reasons for avoiding that approach. As always, the choice is yours to make.

> 可以理解，这是一个具有争议性的话题，我也知道有很大一部分人依然采用 Impl 后缀的方式来命名实现类。即便如此，我们仍然有强烈的理由不这么做。当然，选择权在你自己手上。

Using Separated Interface may be more a matter of style in cases where the Service is always domain specific and will never have a technical implementation or multiple implementations. As Fowler [Fowler, P of EAA] states, Separated Interface is useful if you have certain decoupling goals: “A client that needs the dependency to the interface can be completely unaware of the implementation.” However, if you are using Dependency Injection or a Factory [Gamma et al.] of Services, even when the Service interface and class are combined, you can still prevent the client from being aware of the implementation. In other words, the following use of the DomainRegistry as Service Factory will decouple the client from implementation:

> 有时，领域服务总是和领域密切相关，并且不会有技术性的实现，或者不会有多个实现，此时采用独立接口便只是一个风格上的问题。Fowler 在[Fowler，P of EAA]中说，独立接口对于解偶来说是有用处的，此时客户端只需要依赖于接口，而不需要知道具体的实现。但是，如果我们使用了依赖注入或者工厂[Gamma et al.]，即便接口和实现类是合并在一起的，我们依然能达到这样的目的。换句话说，以下的 DomainRegistry 可以在客户端和服务实现之间进行解耦，此时的 DomainRegistry 便是一个服务工厂。

```java
// the registry decouples client from implementation knowledge
UserDescriptor userDescriptor =
    DomainRegistry
        .authenticationService()
        .authenticate(aTenantId, aUsername, aPassword);
```

Or if you are using Dependency Injection, you can get similar benefits:

> 或者，如果你使用的是依赖注入，你也可以得到同样的好处：

```java
public class SomeApplicationService ... {
    @Autowired
    private AuthenticationService authenticationService;
    ...
}
```

The inversion-of-control container (such as Spring) injects the Service instance. Since the client never instantiates the Service, it isn’t aware that the interface and implementation are either combined or separated.

> 依赖倒置容器（比如 Spring）将完成服务实例的注入工作。由于客户端并不负责服务的实例化，它并不知道接口类和实现类是分开的还是合并在一起的。

Clearly, some have utter disdain for both the Service Factory and Dependency Injection and prefer to set up inbound dependencies by way of a constructor or pass them in as method parameters. In the end that is the most explicit way to wire dependencies and make code testable, and it could even be considered easier than Dependency Injection. Some may find it beneficial to use a combination of all three depending on the situation, while preferring constructor-based dependency setup overall. Several of the samples in this chapter use DomainRegistry for clarity, though not necessarily indicating a preference. Much of the source code actually distributed online in support of this book leans toward dependency set up by way of constructors, or by passing dependencies directly to methods as parameters.

> 与服务工厂和依赖注入相比，有时他们更倾向于将领域服务作为构造函数参数或者方法参数传入[2]，因为这样的代码拥有很好的可测试性，甚至比依赖注入更加简单。也有人根据实际情况同时采用以上三种方式，并且优先采用基于构造函数的注入方式。本章中有些例子使用了 DomainRegistry，但这并不是说我们应该优先考虑这种方式。互联网上很多源代码例子都倾向于使用构造函数注入，或者直接将领域服务作为方法参数传入。

### 7.3.2 A Calculation Process 一个计算过程

Here’s another example, this time from the current Core Domain (2), the Agile Project Management Context. This Service calculates a result from Values on any number of Aggregates of a specific type. Here I think there is no good reason to use a Separated Interface, at least not at present. The calculations are always performed the same way. Unless that situation changes, we shouldn’t bother separating the interface from the implementation.

> 让我们来看一个计算过程的例子，该例子来自于敏捷项目管理上下文。该例子中的领域服务从多个聚合的值对象中计算所需结果。就目前来看，我们没有必要使用独立接口。该领域服务总是采用相同的方式进行计算。除非有需求变化，不然我们没有必要将接口和实现分离开来。

Cowboy Logic 牛仔的逻辑

- LB: “My stallion brings $5,000 per service, and I’ve got the mares lined up.”
- AJ: “Now that horse is in his domain.”

---

> - LB：“我的公马每次能给我挣 5，000 美元，现在我打算把那些母马也加到服务中来。”
> - AJ：“看来那匹马已经进入它的领域了。”

Image

Recall that the SaaSOvation developers originally created fine-grained static methods on Product to perform the desired calculations. Here’s what happened next . . .

> 回忆一下，SaaSOvation 的开发者们曾经在 Product 上创建了静态方法来完成计算过程，以下是接下来发生的事……

Image

The team’s mentor also pointed to the desirability of using a Domain Service instead of a static method. The idea behind this Service would be very similar to the current design, to calculate and return a BusinessPriorityTotals Value instance. But the Service would have to do a bit more work. This would include finding all outstanding backlog items of a given Scrum product and then totaling each of their individual BusinessPriority Values. Here’s the implementation:

> 团队中的高级开发者同时指出，采用领域服务比静态方法更好。此时的领域服务和当前的静态方法完成相似的功能，即计算并返回一个 BusinessPriorityTotals 值对象。但是，该领域服务还需要完成额外的工作，包括找到一个 Product 中所有未完成的 BacklogItem，然后单独计算它们的 BusinessPriority。以下是实现代码：

```java
package com.saasovation.agilepm.domain.model.product;

import com.saasovation.agilepm.domain.model.DomainRegistry;
import com.saasovation.agilepm.domain.model.tenant.Tenant;

public class BusinessPriorityCalculator {
    public BusinessPriorityCalculator() {
        super();
    }

    public BusinessPriorityTotals businessPriorityTotals(
            Tenant aTenant,
            ProductId aProductId) {
        int totalBenefit = 0;
        int totalPenalty = 0;
        int totalCost = 0;
        int totalRisk = 0;
        java.util.Collection<BacklogItem> outstandingBacklogItems =
            DomainRegistry
                .backlogItemRepository()
                .allOutstandingProductBacklogItems(
                        aTenant,
                        aProductId);
        for (BacklogItem backlogItem : outstandingBacklogItems) {
            if (backlogItem.hasBusinessPriority()) {
                BusinessPriorityRatings ratings =
                    backlogItem.businessPriority().ratings();
                totalBenefit += ratings.benefit();
                totalPenalty += ratings.penalty();
                totalCost += ratings.cost();
                totalRisk += ratings.risk();
            }
        }

        BusinessPriorityTotals businessPriorityTotals =
            new BusinessPriorityTotals(
                    totalBenefit,
                    totalPenalty,
                    totalBenefit + totalPenalty,
                    totalCost,
                    totalRisk);
        return businessPriorityTotals;
    }
}
```

The BacklogItemRepository is used to get all outstanding BacklogItem instances. An outstanding BacklogItem is one with a status type of Planned, Scheduled, or Committed, not either Done or Removed. A Service in the domain is welcome to use Repositories as needed, but accessing Repositories from an Aggregate instance is not a recommended practice.

> BacklogItemRepository 用于查找所有未完成的 BacklogItem 实例。一个未完成的 BacklogItem 是拥有 Planned，Scheduled 或者 Committed 状态的 BacklogItem，而状态为 Done 或 Removed 的 BacklogItem 则是已经完成的。我们并不推荐将资源库对 BacklogItem 的获取放在聚合实例中，相反，将其放在领域服务中则是一种好的做法。

With all outstanding items for a given product, we iterate over them and total each of the ratings of their BusinessPriority. The totals that result from iteratively calculating are used to instantiate a new BusinessPriorityTotals, which is returned to the client. There is no need for a Service calculation process to be complex, though it could be a necessity. This one happens to be rather simple.

> 有了一个 Product 下所有未完成的 BacklogItem，我们便可以对它们进行遍历，并计算出 BusinessPriority 的总和。计算所得的总和进一步用于实例化一个 BusinessPriorityTotals，然后返回给客户端。领域服务不一定非常复杂，即使有时的确会出现这种情况。上面的例子则是非常简单的。

Note from this example that you would absolutely not want this logic to reside in an Application Service. Even if you consider the summing calculation in the for loop to be trivial, it is still business logic. But there’s another reason:

> 请注意，在上面的例子中，我们绝对不能将业务逻辑放到应用层中。即使你认为这里的 for 循环非常简单，它依然是业务逻辑。当然，还有另外的原因：

```java
BusinessPriorityTotals businessPriorityTotals =
    new BusinessPriorityTotals(
            totalBenefit,
            totalPenalty,
            totalBenefit + totalPenalty,
            totalCost,
            totalRisk);
```

As the BusinessPriorityTotals is instantiated, its totalValue attribute is derived from summing the totalBenefit and totalPenalty. This logic is domain specific and must not leak into the Application Layer. We could argue that the BusinessPriorityTotals constructor should itself arrange for this to be derived from the two passed-in parameters. While that might be a way to improve the model, doing so wouldn’t be a justification for moving the remaining calculations into an Application Service.

> 在实例化 BusinessPriorityTotals 时，它的 totalValue 属性由 totalBenefit 和 totalPenalty 相加所得。这是和领域密切相关的业务逻辑，自然不能泄漏到应用层中。当然，你可能会说，可以将 totalBenefit 和 totalPenalty 作为两个参数分别传给应用服务。然而，虽然这是一种改进模型的方式，但这也并不意味着将剩下的计算逻辑放在应用层就是合理的。

Although we don’t house this business logic in an Application Service, an Application Service does serve as the client to the Domain Service:

> 在实例化 BusinessPriorityTotals 时，它的 totalValue 属性由 totalBenefit 和 totalPenalty 相加所得。这是和领域密切相关的业务逻辑，自然不能泄漏到应用层中。当然，你可能会说，可以将 totalBenefit 和 totalPenalty 作为两个参数分别传给应用服务。然而，虽然这是一种改进模型的方式，但这也并不意味着将剩下的计算逻辑放在应用层就是合理的。

```java
public class ProductService ... {
    ...
    private BusinessPriorityTotals productBusinessPriority(
            String aTenantId,
            String aProductId) {
        BusinessPriorityTotals productBusinessPriority =
                DomainRegistry
                    .businessPriorityCalculator()
                    .businessPriorityTotals(
                            new TenantId(aTenantId),
                            new ProductId(aProductId));
        return productBusinessPriority;
    }
}
```

In this case a private method in the Application Service is responsible for requesting the total business priority for the product. Here the method may be supplying just one part of the payload returned to the client of ProductService, such as the user interface.

> 在上例中，应用层中的一个私有方法负责获取一个 Product 的总业务优先级。该方法可能只需要向 ProductService 的客户端（比如用户界面）提供 BusinessPriorityTotals 的部分数据即可。

### 7.3.3 Transformation Services 转换服务

The more technical Domain Service implementations that definitely live in Infrastructure are often those used for integration. For that reason I have delegated such examples to Integrating Bounded Contexts (13). There you’ll see the Service interfaces, implementation classes, and also Adapters [Gamma et al.] and translators used by the implementations.

> 在基础设施层中，更加技术性的领域服务通常是那些用于集成目的的服务。正是这个原因，我们将与此相关的例子放在了集成限界上下文（13）中，其中你将看到领域服务接口、实现类、适配器[Gamma et al.]和不同的转换器。

### 7.3.4 Using a Mini-Layer of Domain Services 为领域服务创建一个迷你层

Sometimes it may be desirable to create a “mini-layer” of Domain Services above the rest of your domain model Entities and Value Objects. As I previously indicated, this will often lead down the precarious path of Anemic Domain Model, which should be considered an anti-pattern.

> 有时我们可能希望在实体和值对象之上创建一个领域服务的迷你层。正如我先前所说，这样做可能会导致贫血领域模型这种反模式。

Yet, there are some systems where designing in the mini-layer of Domain Services makes more sense than in others and will not lead to Anemic Domain Model. It depends on the characteristics of the domain model, and in the case of the Identity and Access Context this is actually quite helpful.

> 但是，对于有些系统来说，为领域服务创建一个不至于导致贫血领域模型的迷你层是值得的。当然，这取决于领域模型的特征。对于本书的身份与访问上下文来说，这样的做法是非常有用的。

If you were to experience working in such a domain and you did decide to produce a mini-layer of Domain Services, remember that such are always different from Application Services in the Application Layer. Address transactions and security as application concerns in Application Services, not in Domain Services.

> 如果你正工作在这样的领域里，并且你决定为领域服务创建一个迷你层，请注意这样的迷你层和应用层中的服务是不同的。在应用服务中，我们关心的是事务和安全，但是这些不应该出现在领域服务中。

## 7.4 TESTING SERVICES 测试领域服务

We want to test our Services to make sure we gain a client perspective on how we should model. We want our domain-focused tests to reflect the way the model should be used, while at this point ignoring some of the finer software correctness focus.

> 我们希望对领域服务进行测试，并且希望从客户端的角度对领域服务进行建模，同时我们希望测试能够反映出领域服务的使用方式。

Isn’t It a Bit Late to Test? 此时进行测试是否为时已晚？

I have normally introduced tests before implementations. I did show some test-first code snippets earlier when analyzing the need for a Service. It’s just that I found it more natural to discuss the implementation a bit earlier in this chapter, that’s all. However, this does show that test-first isn’t an absolute necessity, although it may limit a proper modeling focus.

> 在前面的章节中，我正式向大家介绍了测试驱动开发，也向大家展示了一些例子。在本章中我并没有这么做，单单只是因为我希望尽早地与大家讨论对领域服务的实现。但是，这的确也说明测试先行的策略并不总是必要的，虽然不这样做可能会遗漏一些建模关注点。

These tests demonstrate how to properly use AuthenticationService, and we first test against the successful authentication scenario:

> 以下测试展示了如何正确地使用 AuthenticationService，首先我们测试认证成功的场景：

```java
public class AuthenticationServiceTest
        extends IdentityTest {
    public void testAuthenticationSuccess() throws Exception {
        User user = this.getUserFixture();
        DomainRegistry
            .userRepository()
            .add(user);
        UserDescriptor userDescriptor =
            DomainRegistry
                .authenticationService()
                .authenticate(
                        user.tenantId(),
                        user.username(),
                        FIXTURE_PASSWORD);
        assertNotNull(userDescriptor);
        assertEquals(user.tenantId(), userDescriptor.tenantId());
        assertEquals(user.username(), userDescriptor.username());
        assertEquals(user.person().emailAddress(),
                     userDescriptor.emailAddress());
    }
    ...
```

This example shows how the AuthenticationService would be used by an Application Service client. It’s a happy path where that client would successfully authenticate a user by passing expected parameters.

> 上面的例子向我们展示了应用服务的客户端是如何使用 AuthenticationService 的。这是一个顺利的使用场景，此时一个 User 得到了成功的认证。

Note that the Repository could be the full implementation, an in-memory variety, or mocked. It works fine to test with the full implementation if it is fast enough, as long as the test ends with a rollback of the transaction, preventing the buildup of extraneous instances across tests. The kind of Repository implementation used for testing is your choice.

> 请注意，这里的资源库可以是真实产品环境下的资源库，也可以是内存资源库，还可以是模拟（mock）资源库。当然，采用哪种类型的资源库只是一个选择问题。

Next, we demonstrate a scenario under which authentication fails:

> 接下来，我们需要测试认证失败的场景：

```java
public void testAuthenticationTenantFailure() throws Exception {
    User user = this.getUserFixture();
    DomainRegistry
        .userRepository()
        .add(user);

    TenantId bogusTenantId =
        DomainRegistry.tenantRepository().nextIdentity();

    UserDescriptor userDescriptor =
        DomainRegistry
            .authenticationService()
            .authenticate(
                    bogusTenantId, // bogus
                    user.username(),
                    FIXTURE_PASSWORD);
    assertNull(userDescriptor);
}
```

This authentication test fails because we purposely pass in a TenantId that is different from the one in which the User was created. Then there is the invalid username condition to demonstrate:

> 在上例中，由于我们传入的 TenantId 和创建 User 时的 TenantId 不一样，认证过程将失败。此外，如果我们传入的 username 不合法，认证过程也将失败：

```java
public void testAuthenticationUsernameFailure() throws Exception {
    User user = this.getUserFixture();
    DomainRegistry
        .userRepository()
        .add(user);

    UserDescriptor userDescriptor =
        DomainRegistry
            .authenticationService()
            .authenticate(
                    user.tenantId(),
                    "bogususername",
                    user.password());
    assertNull(userDescriptor);
}
```

This authentication test scenario fails because we pass in a wrong username. There’s one last failure scenario demonstrated in these tests:

> 在上例中，由于我们传入了一个错误的 username，认证过程也将失败。最后，还有另外一个认证失败的场景：

```java
    public void testAuthenticationPasswordFailure() throws Exception {
        User user = this.getUserFixture();
        DomainRegistry
            .userRepository()
            .add(user);
        UserDescriptor userDescriptor =
            DomainRegistry
                .authenticationService()
                .authenticate(
                        user.tenantId(),
                        user.username(),
                        "passw0rd");
        assertNull(userDescriptor);
    }
}
```

This test provides the wrong password, which causes it to fail. In all cases when demonstrating failure scenarios the UserDescriptor is returned as null. This is a detail that clients should take note of, as it indicates what they should expect when the user is not authenticated. It also indicates that failing authentication is not an exceptional error, just a normal possibility of this domain. Otherwise, if failing authentication were considered exceptional, we’d make the Service throw an AuthenticationFailedException.

> 在上例中，我们传入了一个错误的 password，认证过程同样会失败。在所有失败的认证过程中，返回的 UserDescriptor 都将是 null。客户端需要知道这样的细节，因为返回的 null 表示对一个 User 的认证不成功。同时，它表示认证失败并不是一个异常性错误，而是该领域中本来就存在的一种可能。否则，我们需要从领域服务中抛出 AuthenticationFailedException 异常。

There are actually a few tests missing. I will leave it to you to test domain scenarios that include when a Tenant is not active and a User that is disabled. After that, you can create tests for the BusinessPriorityCalculator.

> 事实上，我们还缺少了几个测试用例。对于一个 Tenant 处于失活状态和一个 User 处于未激活状态的场景，请读者自行完成测试。在此之后，你可以继续为 BusinessPriorityCalculator 编写测试。

Image

## 7.5 WRAP-UP 本章小结

In this chapter we discussed what a Domain Service is and what it is not, and we analyzed when we should use a Service rather than an operation on an Entity or Value Object. There was more:

> 在本章中，我们讨论了什么是领域服务，什么不是领域服务，并且分析了何时应该采用领域服务。另外还有：

- You learned that recognizing a legitimate need for a Service is necessary to avoid overusing Services.
- You were reminded that overuse of Domain Services leads to Anemic Domain Model, an anti-pattern.
- You saw the specific steps of general practice when implementing a Service.
- You considered the pluses and minuses of using a Separated Interface.
- You reviewed a sample calculation process from the Agile Project Management Context.
- Finally, you considered how to provide exemplary tests to demonstrate how to use the Services our models provide.

---

> - 你学到了不要滥用领域服务。
> - 你学到了滥用领域服务将导致贫血领域模型这种反模式。
> - 你学到了如何实现领域服务。
> - 你学到了使用独立接口的优缺点。
> - 你学习了敏捷项目管理上下文中的一个示例计算过程。
> - 最后，你学到了通过测试来展示对领域服务的使用。接下来，我们将学习一种新的 DDD 战术建模工具——领域事件。

Next, we are going to consider one of the newer DDD tactical modeling tools to appear on the scene. It’s the powerful Domain Event building block pattern.

> 接下来，我们将学习一种新的 DDD 战术建模工具——领域事件。
